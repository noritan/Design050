C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 1   


C51 COMPILER V9.03, COMPILATION OF MODULE CYPM
OBJECT MODULE PLACED IN .\DP8051_Keil_903\Debug\cyPm.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\2.2\PSoC Creator\import\keil\pk51\9.03\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\cyPm.c NOIV LARGE MODDP2 OMF2 VB(1) PR(.\DP8051_Keil_903\Debug\cyPm.lst) DB NOIP OT(5,SIZE) INC
                    -DIR(Generated_Source\PSoC3) OJ(.\DP8051_Keil_903\Debug\cyPm.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: cyPm.c
   3          * Version 3.30
   4          *
   5          * Description:
   6          *  Provides an API for the power management.
   7          *
   8          * Note:
   9          *  Documentation of the API's in this file is located in the
  10          *  System Reference Guide provided with PSoC Creator.
  11          *
  12          ********************************************************************************
  13          * Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
  14          * You may use this file only in accordance with the license, terms, conditions,
  15          * disclaimers, and limitations in the end user license agreement accompanying
  16          * the software package with which this file was provided.
  17          *******************************************************************************/
  18          
  19          #include "cyPm.h"
  20          
  21          
  22          /*******************************************************************
  23          * Place your includes, defines and code here. Do not use merge
  24          * region below unless any component datasheet suggest to do so.
  25          *******************************************************************/
  26          /* `#START CY_PM_HEADER_INCLUDE` */
  27          
  28          /* `#END` */
  29          
  30          
  31          static CY_PM_BACKUP_STRUCT          cyPmBackup;
  32          static CY_PM_CLOCK_BACKUP_STRUCT    cyPmClockBackup;
  33          
  34          /* Convertion table between register's values and frequency in MHz  */
  35          static const uint8 CYCODE cyPmImoFreqReg2Mhz[7u] = {12u, 6u, 24u, 3u, 48u, 62u, 74u};
  36          
  37          /* Function Prototypes */
  38          static void CyPmHibSaveSet(void);
  39          static void CyPmHibRestore(void) ;
  40          
  41          static void CyPmSlpSaveSet(void) ;
  42          static void CyPmSlpRestore(void) ;
  43          
  44          static void CyPmHibSlpSaveSet(void) ;
  45          static void CyPmHibSlpRestore(void) ;
  46          
  47          static void CyPmHviLviSaveDisable(void) ;
  48          static void CyPmHviLviRestore(void) ;
  49          
  50          #if(CY_PSOC5A)
              
                  /***************************************************************************
                  * The PICU interupt event is not allowed to act as wakeup source for PSoC 5.
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 2   

                  * To prevent accidental wakeup all the PICU interrupts are disabled before
                  * Sleep and Hibernate low power modes entry. In case of Sleep mode registers
                  * values must be restored on wakeup, but in case of Hibernate low power mode
                  * there is no sense in saving/restoring registers values as the only wakeup
                  * source for this mode is external reset (XRES). For more information refer
                  * to the PSoC 5 device TRM.
                  ***************************************************************************/
              
                  static void CyPmSavePicuInterrupts(void);
                  static void CyPmDisablePicuInterrupts(void) ;
                  static void CyPmRestorePicuInterrupts(void) ;
              
              #endif  /* (CY_PSOC5A) */
  67          
  68          
  69          /*******************************************************************************
  70          * Function Name: CyPmSaveClocks
  71          ********************************************************************************
  72          *
  73          * Summary:
  74          *  This function is called in preparation for entering sleep or hibernate low
  75          *  power modes. Saves all state of the clocking system that does not persist
  76          *  during sleep/hibernate or that needs to be altered in preparation for
  77          *  sleep/hibernate. Shutdowns all the digital and analog clock dividers for the
  78          *  active power mode configuration.
  79          *
  80          *  Switches the master clock over to the IMO and shuts down the PLL and MHz
  81          *  Crystal. The IMO frequency is set to either 12 MHz or 48 MHz to match the
  82          *  Design-Wide Resources System Editor "Enable Fast IMO During Startup" setting.
  83          *  The ILO and 32 KHz oscillators are not impacted. The current Flash wait state
  84          *  setting is saved and the Flash wait state setting is set for the current IMO
  85          *  speed.
  86          *
  87          *  Note If the Master Clock source is routed through the DSI inputs, then it
  88          *  must be set manually to another source before using the
  89          *  CyPmSaveClocks()/CyPmRestoreClocks() functions.
  90          *
  91          * Parameters:
  92          *  None
  93          *
  94          * Return:
  95          *  None
  96          *
  97          * Side Effects:
  98          *  All peripheral clocks are going to be off after this API method call.
  99          *
 100          *******************************************************************************/
 101          void CyPmSaveClocks(void) 
 102          {
 103   1          /* Digital and analog clocks - save enable state and disable them all */
 104   1          cyPmClockBackup.enClkA = CY_PM_ACT_CFG1_REG & CY_PM_ACT_EN_CLK_A_MASK;
 105   1          cyPmClockBackup.enClkD = CY_PM_ACT_CFG2_REG;
 106   1          CY_PM_ACT_CFG1_REG &= ((uint8)(~CY_PM_ACT_EN_CLK_A_MASK));
 107   1          CY_PM_ACT_CFG2_REG &= ((uint8)(~CY_PM_ACT_EN_CLK_D_MASK));
 108   1      
 109   1          /* Save current flash wait cycles and set the maximum value */
 110   1          cyPmClockBackup.flashWaitCycles = CY_PM_CACHE_CR_CYCLES_MASK & CY_PM_CACHE_CR_REG;
 111   1          CyFlash_SetWaitCycles(CY_PM_MAX_FLASH_WAIT_CYCLES);
 112   1      
 113   1          /* IMO - save current IMO MHz OSC frequency and USB mode is on bit */
 114   1          cyPmClockBackup.imoFreq = CY_PM_FASTCLK_IMO_CR_REG & CY_PM_FASTCLK_IMO_CR_FREQ_MASK;
 115   1          cyPmClockBackup.imoUsbClk = CY_PM_FASTCLK_IMO_CR_REG & CY_PM_FASTCLK_IMO_CR_USB;
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 3   

 116   1      
 117   1          /* IMO doubler - save enable state */
 118   1          if(0u != (CY_PM_FASTCLK_IMO_CR_REG & CY_PM_FASTCLK_IMO_CR_F2XON))
 119   1          {
 120   2              /* IMO doubler enabled - save and disable */
 121   2              cyPmClockBackup.imo2x = CY_PM_ENABLED;
 122   2          }
 123   1          else
 124   1          {
 125   2              /* IMO doubler disabled */
 126   2              cyPmClockBackup.imo2x = CY_PM_DISABLED;
 127   2          }
 128   1      
 129   1          /* IMO - set appropriate frequency for LPM */
 130   1          CyIMO_SetFreq(CY_PM_IMO_FREQ_LPM);
 131   1      
 132   1          /* IMO - save enable state and enable without wait to settle */
 133   1          if(0u != (CY_PM_ACT_CFG0_IMO & CY_PM_ACT_CFG0_REG))
 134   1          {
 135   2              /* IMO - save enabled state */
 136   2              cyPmClockBackup.imoEnable = CY_PM_ENABLED;
 137   2          }
 138   1          else
 139   1          {
 140   2              /* IMO - save disabled state */
 141   2              cyPmClockBackup.imoEnable = CY_PM_DISABLED;
 142   2      
 143   2              /* IMO - enable */
 144   2              CyIMO_Start(CY_PM_IMO_NO_WAIT_TO_SETTLE);
 145   2          }
 146   1      
 147   1          /* IMO - save the current IMOCLK source and set to IMO if not yet */
 148   1          if(0u != (CY_PM_FASTCLK_IMO_CR_REG & CY_PM_FASTCLK_IMO_CR_XCLKEN))
 149   1          {
 150   2              /* DSI or XTAL CLK */
 151   2              cyPmClockBackup.imoClkSrc =
 152   2                  (0u == (CY_PM_CLKDIST_CR_REG & CY_PM_CLKDIST_IMO2X_SRC)) ? CY_IMO_SOURCE_DSI : CY_IMO_SOURCE_X
             -TAL;
 153   2      
 154   2              /* IMO -  set IMOCLK source to MHz OSC */
 155   2              CyIMO_SetSource(CY_IMO_SOURCE_IMO);
 156   2          }
 157   1          else
 158   1          {
 159   2              /* IMO */
 160   2              cyPmClockBackup.imoClkSrc = CY_IMO_SOURCE_IMO;
 161   2          }
 162   1      
 163   1          /* Save clk_imo source */
 164   1          cyPmClockBackup.clkImoSrc = CY_PM_CLKDIST_CR_REG & CY_PM_CLKDIST_IMO_OUT_MASK;
 165   1      
 166   1          /* If IMOCLK2X or SPC OSC is source for clk_imo, set it to IMOCLK */
 167   1          if(CY_PM_CLKDIST_IMO_OUT_IMO != cyPmClockBackup.clkImoSrc)
 168   1          {
 169   2              /* Set IMOCLK to source for clk_imo */
 170   2              CY_PM_CLKDIST_CR_REG = (CY_PM_CLKDIST_CR_REG & ((uint8)(~CY_PM_CLKDIST_IMO_OUT_MASK))) |
 171   2                                      CY_PM_CLKDIST_IMO_OUT_IMO;
 172   2          }    /* Need to change nothing if IMOCLK is source clk_imo */
 173   1      
 174   1          /* IMO doubler - disable it (saved above) */
 175   1          if(0u != (CY_PM_FASTCLK_IMO_CR_REG & CY_PM_FASTCLK_IMO_CR_F2XON))
 176   1          {
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 4   

 177   2              CyIMO_DisableDoubler();
 178   2          }
 179   1      
 180   1          /* Master clock - save divider and set it to divide-by-one (if no yet) */
 181   1          cyPmClockBackup.clkSyncDiv = CY_PM_CLKDIST_MSTR0_REG;
 182   1          if(CY_PM_DIV_BY_ONE != cyPmClockBackup.clkSyncDiv)
 183   1          {
 184   2              CyMasterClk_SetDivider(CY_PM_DIV_BY_ONE);
 185   2          }    /* Need to change nothing if master clock divider is 1 */
 186   1      
 187   1          /* Master clock - save current source */
 188   1          cyPmClockBackup.masterClkSrc = CY_PM_CLKDIST_MSTR1_REG & CY_PM_MASTER_CLK_SRC_MASK;
 189   1      
 190   1          /* Master clock source - set it to IMO if not yet. */
 191   1          if(CY_MASTER_SOURCE_IMO != cyPmClockBackup.masterClkSrc)
 192   1          {
 193   2              CyMasterClk_SetSource(CY_MASTER_SOURCE_IMO);
 194   2          }    /* Need to change nothing if master clock source is IMO */
 195   1      
 196   1          /* Bus clock - save divider and set it, if needed, to divide-by-one */
 197   1          cyPmClockBackup.clkBusDiv = ((uint16) CY_PM_CLK_BUS_MSB_DIV_REG << 8u) | CY_PM_CLK_BUS_LSB_DIV_REG;
 198   1          if(CY_PM_BUS_CLK_DIV_BY_ONE != cyPmClockBackup.clkBusDiv)
 199   1          {
 200   2              CyBusClk_SetDivider(CY_PM_BUS_CLK_DIV_BY_ONE);
 201   2          }    /* Do nothing if saved and actual values are equal */
 202   1      
 203   1          /* Set number of wait cycles for the flash according CPU frequency in MHz */
 204   1          CyFlash_SetWaitCycles((uint8)CY_PM_GET_CPU_FREQ_MHZ);
 205   1      
 206   1          /* PLL - check enable state, disable if needed */
 207   1          if(0u != (CY_PM_FASTCLK_PLL_CFG0_REG & CY_PM_PLL_CFG0_ENABLE))
 208   1          {
 209   2              /* PLL is enabled - save state and disable */
 210   2              cyPmClockBackup.pllEnableState = CY_PM_ENABLED;
 211   2              CyPLL_OUT_Stop();
 212   2          }
 213   1          else
 214   1          {
 215   2              /* PLL is disabled - save state */
 216   2              cyPmClockBackup.pllEnableState = CY_PM_DISABLED;
 217   2          }
 218   1      
 219   1          /* MHz ECO - check enable state and disable if needed */
 220   1          if(0u != (CY_PM_FASTCLK_XMHZ_CSR_REG & CY_PM_XMHZ_CSR_ENABLE))
 221   1          {
 222   2              /* MHz ECO is enabled - save state and disable */
 223   2              cyPmClockBackup.xmhzEnableState = CY_PM_ENABLED;
 224   2              CyXTAL_Stop();
 225   2          }
 226   1          else
 227   1          {
 228   2              /* MHz ECO is disabled - save state */
 229   2              cyPmClockBackup.xmhzEnableState = CY_PM_DISABLED;
 230   2          }
 231   1      
 232   1      
 233   1          /***************************************************************************
 234   1          * Save enable state of delay between the system bus clock and each of the
 235   1          * 4 individual analog clocks. This bit non-retention and it's value should
 236   1          * be restored on wakeup.
 237   1          ***************************************************************************/
 238   1          if(0u != (CY_PM_CLKDIST_DELAY_REG & CY_PM_CLKDIST_DELAY_EN))
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 5   

 239   1          {
 240   2              cyPmClockBackup.clkDistDelay = CY_PM_ENABLED;
 241   2          }
 242   1          else
 243   1          {
 244   2              cyPmClockBackup.clkDistDelay = CY_PM_DISABLED;
 245   2          }
 246   1      }
 247          
 248          
 249          /*******************************************************************************
 250          * Function Name: CyPmRestoreClocks
 251          ********************************************************************************
 252          *
 253          * Summary:
 254          *  Restores any state that was preserved by the last call to CyPmSaveClocks().
 255          *  The Flash wait state setting is also restored.
 256          *
 257          *  Note If the Master Clock source is routed through the DSI inputs, then it
 258          *  must be set manually to another source before using the
 259          *  CyPmSaveClocks()/CyPmRestoreClocks() functions.
 260          *
 261          *  PSoC 3 and PSoC 5LP:
 262          *  The merge region could be used to process state when the megahertz crystal is
 263          *  not ready after the hold-off timeout.
 264          *
 265          *  PSoC 5:
 266          *  The 130 ms is given for the megahertz crystal to stabilize. It's readiness is
 267          *  not verified after the hold-off timeout.
 268          *
 269          * Parameters:
 270          *  None
 271          *
 272          * Return:
 273          *  None
 274          *
 275          *******************************************************************************/
 276          void CyPmRestoreClocks(void) 
 277          {
 278   1          #if (!CY_PSOC5A)
 279   1      
 280   1              cystatus status = CYRET_TIMEOUT;
 281   1              uint16 i;
 282   1      
 283   1          #endif  /* (!CY_PSOC5A) */
 284   1      
 285   1      
 286   1          /* Convertion table between CyIMO_SetFreq() parameters and register's value */
 287   1          const uint8 CYCODE cyPmImoFreqMhz2Reg[7u] = {
 288   1              CY_IMO_FREQ_12MHZ, CY_IMO_FREQ_6MHZ,  CY_IMO_FREQ_24MHZ, CY_IMO_FREQ_3MHZ,
 289   1              CY_IMO_FREQ_48MHZ, 5u, 6u};
 290   1      
 291   1          /* Restore enable state of delay between the system bus clock and ACLKs. */
 292   1          if(CY_PM_ENABLED == cyPmClockBackup.clkDistDelay)
 293   1          {
 294   2              /* Delay for both the bandgap and the delay line to settle out */
 295   2              CyDelayCycles((uint32)(CY_PM_CLK_DELAY_BANDGAP_SETTLE_US + CY_PM_CLK_DELAY_BIAS_SETTLE_US) *
 296   2                              CY_PM_GET_CPU_FREQ_MHZ);
 297   2      
 298   2              CY_PM_CLKDIST_DELAY_REG |= CY_PM_CLKDIST_DELAY_EN;
 299   2          }
 300   1      
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 6   

 301   1          /* MHz ECO restore state */
 302   1          if(CY_PM_ENABLED == cyPmClockBackup.xmhzEnableState)
 303   1          {
 304   2              /***********************************************************************
 305   2              * Enabling XMHZ XTAL. The actual CyXTAL_Start() with non zero wait
 306   2              * period uses FTW for period measurement. This could cause a problem
 307   2              * if CTW/FTW is used as a wake up time in the low power modes APIs.
 308   2              * So, the XTAL wait procedure is implemented with a software delay.
 309   2              ***********************************************************************/
 310   2      
 311   2              /* Enable XMHZ XTAL with no wait */
 312   2              (void) CyXTAL_Start(CY_PM_XTAL_MHZ_NO_WAIT);
 313   2      
 314   2              #if(CY_PSOC5A)
              
                          /* Make a 130 milliseconds delay */
                          CyDelayCycles((uint32)CY_PM_WAIT_200_US * CY_PM_GET_CPU_FREQ_MHZ * CY_PM_MHZ_XTAL_WAIT_NUM_OF_
             -200_US);
              
                      #else
 320   2      
 321   2                  /* Read XERR bit to clear it */
 322   2                  (void) CY_PM_FASTCLK_XMHZ_CSR_REG;
 323   2      
 324   2                  /* Wait */
 325   2                  for(i = CY_PM_MHZ_XTAL_WAIT_NUM_OF_200_US; i > 0u; i--)
 326   2                  {
 327   3                      /* Make a 200 microseconds delay */
 328   3                      CyDelayCycles((uint32)CY_PM_WAIT_200_US * CY_PM_GET_CPU_FREQ_MHZ);
 329   3      
 330   3                      /* High output indicates oscillator failure */
 331   3                      if(0u == (CY_PM_FASTCLK_XMHZ_CSR_REG & CY_PM_XMHZ_CSR_XERR))
 332   3                      {
 333   4                          status = CYRET_SUCCESS;
 334   4                          break;
 335   4                      }
 336   3                  }
 337   2      
 338   2                  if(CYRET_TIMEOUT == status)
 339   2                  {
 340   3                      /*******************************************************************
 341   3                      * Process the situation when megahertz crystal is not ready.
 342   3                      * Time to stabialize value is crystal specific.
 343   3                      *******************************************************************/
 344   3      
 345   3                      /* `#START_MHZ_ECO_TIMEOUT` */
 346   3      
 347   3                      /* `#END` */
 348   3                  }
 349   2      
 350   2              #endif  /* (CY_PSOC5A) */
 351   2      
 352   2          }   /* (CY_PM_ENABLED == cyPmClockBackup.xmhzEnableState) */
 353   1      
 354   1      
 355   1          /* Temprorary set the maximum flash wait cycles */
 356   1          CyFlash_SetWaitCycles(CY_PM_MAX_FLASH_WAIT_CYCLES);
 357   1      
 358   1          /* The XTAL and DSI clocks are ready to be source for Master clock. */
 359   1          if((CY_PM_MASTER_CLK_SRC_XTAL == cyPmClockBackup.masterClkSrc) ||
 360   1             (CY_PM_MASTER_CLK_SRC_DSI  == cyPmClockBackup.masterClkSrc))
 361   1          {
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 7   

 362   2              /* Restore Master clock's divider */
 363   2              if(CY_PM_CLKDIST_MSTR0_REG != cyPmClockBackup.clkSyncDiv)
 364   2              {
 365   3                  /* Restore Master clock divider */
 366   3                  CyMasterClk_SetDivider(cyPmClockBackup.clkSyncDiv);
 367   3              }
 368   2      
 369   2              /* Restore Master clock source */
 370   2              CyMasterClk_SetSource(cyPmClockBackup.masterClkSrc);
 371   2          }
 372   1      
 373   1          /* IMO - restore IMO frequency */
 374   1          if((0u != (cyPmClockBackup.imoUsbClk & CY_PM_FASTCLK_IMO_CR_USB)) &&
 375   1              (CY_IMO_FREQ_24MHZ == cyPmImoFreqMhz2Reg[cyPmClockBackup.imoFreq]))
 376   1          {
 377   2              /* Restore IMO frequency (24 MHz) and trim it for USB */
 378   2              CyIMO_SetFreq(CY_IMO_FREQ_USB);
 379   2          }
 380   1          else
 381   1          {
 382   2              /* Restore IMO frequency */
 383   2              CyIMO_SetFreq(cyPmImoFreqMhz2Reg[cyPmClockBackup.imoFreq]);
 384   2      
 385   2              if(0u != (cyPmClockBackup.imoUsbClk & CY_PM_FASTCLK_IMO_CR_USB))
 386   2              {
 387   3                  CY_PM_FASTCLK_IMO_CR_REG |= CY_PM_FASTCLK_IMO_CR_USB;
 388   3              }
 389   2              else
 390   2              {
 391   3                  CY_PM_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_PM_FASTCLK_IMO_CR_USB));
 392   3              }
 393   2          }
 394   1      
 395   1          /* IMO - restore enable state if needed */
 396   1          if((CY_PM_ENABLED == cyPmClockBackup.imoEnable) &&
 397   1             (0u == (CY_PM_ACT_CFG0_IMO & CY_PM_ACT_CFG0_REG)))
 398   1          {
 399   2              /* IMO - restore enabled state */
 400   2              CyIMO_Start(CY_PM_IMO_NO_WAIT_TO_SETTLE);
 401   2          }
 402   1      
 403   1          /* IMO - restore disable state if needed */
 404   1          if((CY_PM_DISABLED == cyPmClockBackup.imoEnable) &&
 405   1             (0u != (CY_PM_ACT_CFG0_IMO & CY_PM_ACT_CFG0_REG)))
 406   1          {
 407   2              CyIMO_Stop();
 408   2          }
 409   1      
 410   1          /* IMO - restore IMOCLK source */
 411   1          CyIMO_SetSource(cyPmClockBackup.imoClkSrc);
 412   1      
 413   1          /* Restore IMO doubler enable state (turned off by CyPmSaveClocks()) */
 414   1          if(CY_PM_ENABLED == cyPmClockBackup.imo2x)
 415   1          {
 416   2              CyIMO_EnableDoubler();
 417   2          }
 418   1      
 419   1          /* IMO - restore clk_imo source, if needed */
 420   1          if(cyPmClockBackup.clkImoSrc != (CY_PM_CLKDIST_CR_REG & CY_PM_CLKDIST_IMO_OUT_MASK))
 421   1          {
 422   2              CY_PM_CLKDIST_CR_REG = (CY_PM_CLKDIST_CR_REG & ((uint8)(~CY_PM_CLKDIST_IMO_OUT_MASK))) |
 423   2                                      cyPmClockBackup.clkImoSrc;
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 8   

 424   2          }
 425   1      
 426   1          /* PLL restore state */
 427   1          if(CY_PM_ENABLED == cyPmClockBackup.pllEnableState)
 428   1          {
 429   2              /***********************************************************************
 430   2              * Enable PLL. The actual CyPLL_OUT_Start() without wait period uses FTW
 431   2              * for period measurement. This could cause a problem if CTW/FTW is used
 432   2              * as a wakeup time in the low power modes APIs. To omit this issue PLL
 433   2              * wait procedure is implemented with a software delay.
 434   2              ***********************************************************************/
 435   2      
 436   2              /* Enable PLL */
 437   2              (void) CyPLL_OUT_Start(CY_PM_PLL_OUT_NO_WAIT);
 438   2      
 439   2              /* Make a 250 us delay */
 440   2              CyDelayCycles((uint32)CY_PM_WAIT_250_US * CY_PM_GET_CPU_FREQ_MHZ);
 441   2          }   /* (CY_PM_ENABLED == cyPmClockBackup.pllEnableState) */
 442   1      
 443   1      
 444   1          /* PLL and IMO is ready to be source for Master clock */
 445   1          if((CY_PM_MASTER_CLK_SRC_IMO == cyPmClockBackup.masterClkSrc) ||
 446   1             (CY_PM_MASTER_CLK_SRC_PLL == cyPmClockBackup.masterClkSrc))
 447   1          {
 448   2              /* Restore Master clock divider */
 449   2              if(CY_PM_CLKDIST_MSTR0_REG != cyPmClockBackup.clkSyncDiv)
 450   2              {
 451   3                  CyMasterClk_SetDivider(cyPmClockBackup.clkSyncDiv);
 452   3              }
 453   2      
 454   2              /* Restore Master clock source */
 455   2              CyMasterClk_SetSource(cyPmClockBackup.masterClkSrc);
 456   2          }
 457   1      
 458   1          /* Bus clock - restore divider, if needed */
 459   1          if(cyPmClockBackup.clkBusDiv != (((uint16) CY_PM_CLK_BUS_MSB_DIV_REG << 8u) | CY_PM_CLK_BUS_LSB_DIV_RE
             -G))
 460   1          {
 461   2              CyBusClk_SetDivider(cyPmClockBackup.clkBusDiv);
 462   2          }
 463   1      
 464   1          /* Restore flash wait cycles */
 465   1          CY_PM_CACHE_CR_REG = ((CY_PM_CACHE_CR_REG & ((uint8)(~CY_PM_CACHE_CR_CYCLES_MASK))) |
 466   1                                 cyPmClockBackup.flashWaitCycles);
 467   1      
 468   1          /* Digital and analog clocks - restore state */
 469   1          CY_PM_ACT_CFG1_REG = cyPmClockBackup.enClkA;
 470   1          CY_PM_ACT_CFG2_REG = cyPmClockBackup.enClkD;
 471   1      }
 472          
 473          
 474          /*******************************************************************************
 475          * Function Name: CyPmAltAct
 476          ********************************************************************************
 477          *
 478          * Summary:
 479          *  Puts the part into the Alternate Active (Standby) state. The Alternate Active
 480          *  state can allow for any of the capabilities of the device to be active, but
 481          *  the operation of this function is dependent on the CPU being disabled during
 482          *  the Alternate Active state. The configuration code and the component APIs
 483          *  will configure the template for the Alternate Active state to be the same as
 484          *  the Active state with the exception that the CPU will be disabled during
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 9   

 485          *  Alternate Active.
 486          *
 487          *  Note Before calling this function, you must manually configure the power mode
 488          *  of the source clocks for the timer that is used as the wakeup timer.
 489          *
 490          *  PSoC 3:
 491          *  Before switching to Alternate Active, if a wakeupTime other than NONE is
 492          *  specified, then the appropriate timer state is configured as specified with
 493          *  the interrupt for that timer disabled.  The wakeup source will be the
 494          *  combination of the values specified in the wakeupSource and any timer
 495          *  specified in the wakeupTime argument.  Once the wakeup condition is
 496          *  satisfied, then all saved state is restored and the function returns in the
 497          *  Active state.
 498          *
 499          *  Note that if the wakeupTime is made with a different value, the period before
 500          *  the wakeup occurs can be significantly shorter than the specified time.  If
 501          *  the next call is made with the same wakeupTime value, then the wakeup will
 502          *  occur the specified period after the previous wakeup occurred.
 503          *
 504          *  If a wakeupTime other than NONE is specified, then upon exit the state of the
 505          *  specified timer will be left as specified by wakeupTime with the timer
 506          *  enabled and the interrupt disabled.  If the CTW, FTW or One PPS is already
 507          *  configured for wakeup, for example with the SleepTimer or RTC components,
 508          *  then specify NONE for the wakeupTime and include the appropriate source for
 509          *  wakeupSource.
 510          *
 511          *  PSoC 5:
 512          *  This function is used to both enter the Alternate Active mode and halt the
 513          *  processor.  For PSoC 3 these two actions must be paired together.  With
 514          *  PSoC 5 the processor can be halted independently with the __WFI() function
 515          *  from the CMSIS library that is included in Creator.  This function should be
 516          *  used instead when the action required is just to halt the processor until an
 517          *  enabled interrupt occurs.
 518          *
 519          *  Neither of the parameters to the CyPmAltAct() function are used. The
 520          *  parameters must be set to 0 (PM_ALT_ACT_TIME_NONE and PM_ALT_ACT_SRC_NONE).
 521          *  The wake up time configuration can be done by a separate component: the CTW
 522          *  wakeup interval should be configured with the Sleep Timer component and one
 523          *  second interval should be configured with the RTC component.
 524          *
 525          *  Upon function execution the device will be switched from Active to Alternate
 526          *  Active mode and the CPU will be halted. When an enabled interrupt occurs the
 527          *  device will be switched to Active mode and the CPU will be started. Note that
 528          *  if a wakeup event occurs and the associated interrupt is not enabled, then
 529          *  the device will switch to Active mode with the CPU still halted. The CPU will
 530          *  remain halted until an enabled interrupt occurs.
 531          *
 532          *  PSoC 5LP:
 533          *  This function is used to both enter the Alternate Active mode and halt the
 534          *  processor.  For PSoC 3 these two actions must be paired together.  With PSoC
 535          *  5LP the processor can be halted independently with the __WFI() function from
 536          *  the CMSIS library that is included in Creator.  This function should be used
 537          *  instead when the action required is just to halt the processor until an
 538          *  enabled interrupt occurs.
 539          *
 540          *  The wakeupTime parameter is not used for this device. It must be set to zero
 541          *  (PM_ALT_ACT_TIME_NONE). The wake up time configuration can be done by a
 542          *  separate component: the CTW wakeup interval should be configured with the
 543          *  Sleep Timer component and one second interval should be configured with the
 544          *  RTC component.
 545          *
 546          *  The wakeup behavior depends on wakeupSource parameter in the following
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 10  

 547          *  manner: upon function execution the device will be switched from Active to
 548          *  Alternate Active mode and then the CPU will be halted. When an enabled wakeup
 549          *  event occurs the device will return to Active mode.  Similarly when an
 550          *  enabled interrupt occurs the CPU will be started. These two actions will
 551          *  occur together provided that the event that occurs is an enabled wakeup
 552          *  source and also generates an interrupt. If just the wakeup event occurs then
 553          *  the device will be in Active mode, but the CPU will remain halted waiting for
 554          *  an interrupt. If an interrupt occurs from something other than a wakeup
 555          *  source, then the CPU will restart with the device in Alternate Active mode
 556          *  until a wakeup event occurs.
 557          *
 558          *  For example, if CyPmAltAct(PM_ALT_ACT_TIME_NONE, PM_ALT_ACT_SRC_PICU) is
 559          *  called and PICU interrupt occurs, the CPU will be started and device will be
 560          *  switched into Active mode. And if CyPmAltAct(PM_ALT_ACT_TIME_NONE,
 561          *  PM_ALT_ACT_SRC_NONE) is called and PICU interrupt occurs, the CPU will be
 562          *  started while device remains in Alternate Active mode.
 563          *
 564          * Parameters:
 565          *  wakeupTime: Specifies a timer wakeup source and the frequency of that
 566          *              source. For PSoC 5 and PSoC 5LP this parameter is ignored.
 567          *
 568          *           Define                      Time
 569          *  PM_ALT_ACT_TIME_NONE             None
 570          *  PM_ALT_ACT_TIME_ONE_PPS          One PPS: 1 second
 571          *  PM_ALT_ACT_TIME_CTW_2MS          CTW: 2 ms
 572          *  PM_ALT_ACT_TIME_CTW_4MS          CTW: 4 ms
 573          *  PM_ALT_ACT_TIME_CTW_8MS          CTW: 8 ms
 574          *  PM_ALT_ACT_TIME_CTW_16MS         CTW: 16 ms
 575          *  PM_ALT_ACT_TIME_CTW_32MS         CTW: 32 ms
 576          *  PM_ALT_ACT_TIME_CTW_64MS         CTW: 64 ms
 577          *  PM_ALT_ACT_TIME_CTW_128MS        CTW: 128 ms
 578          *  PM_ALT_ACT_TIME_CTW_256MS        CTW: 256 ms
 579          *  PM_ALT_ACT_TIME_CTW_512MS        CTW: 512 ms
 580          *  PM_ALT_ACT_TIME_CTW_1024MS       CTW: 1024 ms
 581          *  PM_ALT_ACT_TIME_CTW_2048MS       CTW: 2048 ms
 582          *  PM_ALT_ACT_TIME_CTW_4096MS       CTW: 4096 ms
 583          *  PM_ALT_ACT_TIME_FTW(1-256)*       FTW: 10us to 2.56 ms
 584          *
 585          *  *Note:   PM_ALT_ACT_TIME_FTW() is a macro that takes an argument that
 586          *           specifies how many increments of 10 us to delay.
 587                      For PSoC 3 silicon the valid range of  values is 1 to 256.
 588          *
 589          *  wakeUpSource:    Specifies a bitwise mask of wakeup sources. In addition, if
 590          *                   a wakeupTime has been specified the associated timer will be
 591          *                   included as a wakeup source. For PSoC 5 this parameter is
 592          *                   ignored.
 593          *
 594          *           Define                      Source
 595          *  PM_ALT_ACT_SRC_NONE              None
 596          *  PM_ALT_ACT_SRC_COMPARATOR0       Comparator 0
 597          *  PM_ALT_ACT_SRC_COMPARATOR1       Comparator 1
 598          *  PM_ALT_ACT_SRC_COMPARATOR2       Comparator 2
 599          *  PM_ALT_ACT_SRC_COMPARATOR3       Comparator 3
 600          *  PM_ALT_ACT_SRC_INTERRUPT         Interrupt
 601          *  PM_ALT_ACT_SRC_PICU              PICU
 602          *  PM_ALT_ACT_SRC_I2C               I2C
 603          *  PM_ALT_ACT_SRC_BOOSTCONVERTER    Boost Converter
 604          *  PM_ALT_ACT_SRC_FTW               Fast Timewheel*
 605          *  PM_ALT_ACT_SRC_VD                High and Low Voltage Detection (HVI, LVI)*
 606          *  PM_ALT_ACT_SRC_CTW               Central Timewheel**
 607          *  PM_ALT_ACT_SRC_ONE_PPS           One PPS**
 608          *  PM_ALT_ACT_SRC_LCD               LCD
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 11  

 609          *
 610          *  *Note : FTW and HVI/LVI wakeup signals are in the same mask bit.
 611          *  **Note: CTW and One PPS wakeup signals are in the same mask bit.
 612          *
 613          *  When specifying a Comparator as the wakeupSource an instance specific define
 614          *  should be used that will track with the specific comparator that the instance
 615          *  is placed into. As an example, for a Comparator instance named MyComp the
 616          *  value to OR into the mask is: MyComp_ctComp__CMP_MASK.
 617          *
 618          *  When CTW, FTW or One PPS is used as a wakeup source, the CyPmReadStatus()
 619          *  function must be called upon wakeup with corresponding parameter. Please
 620          *  refer to the CyPmReadStatus() API in the System Reference Guide for more
 621          *  information.
 622          *
 623          * Return:
 624          *  None
 625          *
 626          * Reentrant:
 627          *  No
 628          *
 629          * Side Effects:
 630          *  If a wakeupTime other than NONE is specified, then upon exit the state of the
 631          *  specified timer will be left as specified by wakeupTime with the timer
 632          *  enabled and the interrupt disabled.  Also, the ILO 1 KHz (if CTW timer is
 633          *  used as wakeup time) or ILO 100 KHz (if FTW timer is used as wakeup time)
 634          *  will be left started.
 635          *
 636          *******************************************************************************/
 637          void CyPmAltAct(uint16 wakeupTime, uint16 wakeupSource) 
 638          {
 639   1          #if(CY_PSOC5)
              
                      /* Arguments expected to be 0 */
                      CYASSERT(PM_ALT_ACT_TIME_NONE == wakeupTime);
              
                      #if(CY_PSOC5A)
              
                          /* The wakeupSource argument expected to be 0 */
                          CYASSERT(PM_ALT_ACT_SRC_NONE  == wakeupSource);
              
                          if(0u != wakeupSource)
                          {
                              /* To remove unreferenced local variable warning */
                          }
              
                      #endif /* (CY_PSOC5A) */
              
                      if(0u != wakeupTime)
                      {
                          /* To remove unreferenced local variable warning */
                      }
              
                  #endif /* (CY_PSOC5) */
 662   1      
 663   1      
 664   1          #if(CY_PSOC3)
 665   1      
 666   1              /* FTW - save current and set new configuration */
 667   1              if((wakeupTime >= PM_ALT_ACT_TIME_FTW(1u)) && (wakeupTime <= PM_ALT_ACT_TIME_FTW(256u)))
 668   1              {
 669   2                  CyPmFtwSetInterval(PM_ALT_ACT_FTW_INTERVAL(wakeupTime));
 670   2      
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 12  

 671   2                  /* Include associated timer to the wakeupSource */
 672   2                  wakeupSource |= PM_ALT_ACT_SRC_FTW;
 673   2              }
 674   1      
 675   1              /* CTW - save current and set new configuration */
 676   1              if((wakeupTime >= PM_ALT_ACT_TIME_CTW_2MS) && (wakeupTime <= PM_ALT_ACT_TIME_CTW_4096MS))
 677   1              {
 678   2                  /* Save current CTW configuration and set new one */
 679   2                  CyPmCtwSetInterval((uint8)(wakeupTime - 1u));
 680   2      
 681   2                  /* Include associated timer to the wakeupSource */
 682   2                  wakeupSource |= PM_ALT_ACT_SRC_CTW;
 683   2              }
 684   1      
 685   1              /* 1PPS - save current and set new configuration */
 686   1              if(PM_ALT_ACT_TIME_ONE_PPS == wakeupTime)
 687   1              {
 688   2                  /* Save current 1PPS configuration and set new one */
 689   2                  CyPmOppsSet();
 690   2      
 691   2                  /* Include associated timer to the wakeupSource */
 692   2                  wakeupSource |= PM_ALT_ACT_SRC_ONE_PPS;
 693   2              }
 694   1      
 695   1          #endif /* (CY_PSOC3) */
 696   1      
 697   1      
 698   1          #if(CY_PSOC3 || CY_PSOC5LP)
 699   1      
 700   1              /* Save and set new wake up configuration */
 701   1      
 702   1              /* Interrupt, PICU, I2C, Boost converter, CTW/1PPS */
 703   1              cyPmBackup.wakeupCfg0 = CY_PM_WAKEUP_CFG0_REG;
 704   1              CY_PM_WAKEUP_CFG0_REG = (uint8) (wakeupSource >> 4u);
 705   1      
 706   1              /* Comparators */
 707   1              cyPmBackup.wakeupCfg1 = CY_PM_WAKEUP_CFG1_REG;
 708   1              CY_PM_WAKEUP_CFG1_REG = (((uint8) wakeupSource) & CY_PM_WAKEUP_SRC_CMPS_MASK);
 709   1      
 710   1              /* LCD */
 711   1              cyPmBackup.wakeupCfg2 = CY_PM_WAKEUP_CFG2_REG;
 712   1              CY_PM_WAKEUP_CFG2_REG = ((uint8) ((wakeupSource >> 12u) & 0x01u));
 713   1      
 714   1          #endif  /* (CY_PSOC3 || CY_PSOC5LP) */
 715   1      
 716   1      
 717   1          /* Switch to the Alternate Active mode */
 718   1          CY_PM_MODE_CSR_REG = ((CY_PM_MODE_CSR_REG & ((uint8)(~CY_PM_MODE_CSR_MASK))) | CY_PM_MODE_CSR_ALT_ACT)
             -;
 719   1      
 720   1          /* Recommended readback. */
 721   1          (void) CY_PM_MODE_CSR_REG;
 722   1      
 723   1          /* Two recommended NOPs to get into the mode. */
 724   1          CY_NOP;
 725   1          CY_NOP;
 726   1      
 727   1          /* Execute WFI instruction (for ARM-based devices only) */
 728   1          CY_PM_WFI;
 729   1      
 730   1          /* Point of return from Alternate Active Mode */
 731   1      
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 13  

 732   1          #if(CY_PSOC3 || CY_PSOC5LP)
 733   1      
 734   1              /* Restore wake up configuration */
 735   1              CY_PM_WAKEUP_CFG0_REG = cyPmBackup.wakeupCfg0;
 736   1              CY_PM_WAKEUP_CFG1_REG = cyPmBackup.wakeupCfg1;
 737   1              CY_PM_WAKEUP_CFG2_REG = cyPmBackup.wakeupCfg2;
 738   1      
 739   1          #endif  /* (CY_PSOC3 || CY_PSOC5LP) */
 740   1      }
 741          
 742          
 743          /*******************************************************************************
 744          * Function Name: CyPmSleep
 745          ********************************************************************************
 746          *
 747          * Summary:
 748          *  Puts the part into the Sleep state.
 749          *
 750          *  Note Before calling this function, you must manually configure the power
 751          *  mode of the source clocks for the timer that is used as wakeup timer.
 752          *
 753          *  Note Before calling this function, you must prepare clock tree configuration
 754          *  for the low power mode by calling CyPmSaveClocks(). And restore clock
 755          *  configuration after CyPmSleep() execution by calling CyPmRestoreClocks(). See
 756          *  Power Management section, Clock Configuration subsection of the System
 757          *  Reference Guide for more information.
 758          *
 759          *  PSoC 3:
 760          *  Before switching to Sleep, if a wakeupTime other than NONE is specified,
 761          *  then the appropriate timer state is configured as specified with the
 762          *  interrupt for that timer disabled.  The wakeup source will be the combination
 763          *  of the values specified in the wakeupSource and any timer specified in the
 764          *  wakeupTime argument.  Once the wakeup condition is satisfied, then all saved
 765          *  state is restored and the function returns in the Active state.
 766          *
 767          *  Note that if the wakeupTime is made with a different value, the period before
 768          *  the wakeup occurs can be significantly shorter than the specified time.  If
 769          *  the next call is made with the same wakeupTime value, then the wakeup will
 770          *  occur the specified period after the previous wakeup occurred.
 771          *
 772          *  If a wakeupTime other than NONE is specified, then upon exit the state of the
 773          *  specified timer will be left as specified by wakeupTime with the timer
 774          *  enabled and the interrupt disabled.  If the CTW or One PPS is already
 775          *  configured for wakeup, for example with the SleepTimer or RTC components,
 776          *  then specify NONE for the wakeupTime and include the appropriate source for
 777          *  wakeupSource.
 778          *
 779          *  PSoC 5:
 780          *  Neither parameter to this function is used for PSoC 5. The parameters must be
 781          *  set to 0 (PM_SLEEP_TIME_NONE and PM_SLEEP_SRC_NONE).  The device will go
 782          *  into Sleep mode until it is woken by an interrupt from the Central Time Wheel
 783          *  (CTW). The CTW must already be configured to generate an interrupt. It is
 784          *  configured using the SleepTimer component.  Only the CTW can be used to wake
 785          *  the device from sleep mode.  The other wakeup sources, Once per second or
 786          *  Port Interrupt Controller (PICU), cannot be used reliably with PSoC 5. This
 787          *  function automatically disables these interrupt sources and then restores
 788          *  them after the devices is woken by the CTW.
 789          *
 790          *  The duration of sleep needs to be controlled so that the device doesn't wake
 791          *  up too soon after going to sleep or remain asleep for too long.  Reliable
 792          *  sleep times of between 1 ms and 128 ms can be supported.  This requirement is
 793          *  satisfied with CTW settings of 4, 8, 16, 32, 64, 128 or 256 ms.  To control
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 14  

 794          *  the sleep time the CTW is reset automatically just before putting the device
 795          *  to sleep.  The resulting wakeup time is half the duration programmed into the
 796          *  CTW with an uncertainty of 1 ms due to the arrival time of the first ILO
 797          *  clock edge. For example, the setting of 4 ms will result in a sleep time
 798          *  between 1 ms and 2 ms.
 799          *
 800          *  PSoC 5LP:
 801          *  The wakeupTime parameter is not used and the only NONE can be specified.
 802          *  The wakeup time must be configured with the component, SleepTimer for CTW
 803          *  intervals and RTC for 1PPS interval. The component must be configured to
 804          *  generate an interrrupt.
 805          *
 806          * Parameters:
 807          *  wakeupTime:      Specifies a timer wakeup source and the frequency of that
 808          *                   source. For PSoC 5 and PSoC 5LP, this parameter is ignored.
 809          *
 810          *           Define                      Time
 811          *  PM_SLEEP_TIME_NONE               None
 812          *  PM_SLEEP_TIME_ONE_PPS            One PPS: 1 second
 813          *  PM_SLEEP_TIME_CTW_2MS            CTW: 2 ms
 814          *  PM_SLEEP_TIME_CTW_4MS            CTW: 4 ms
 815          *  PM_SLEEP_TIME_CTW_8MS            CTW: 8 ms
 816          *  PM_SLEEP_TIME_CTW_16MS           CTW: 16 ms
 817          *  PM_SLEEP_TIME_CTW_32MS           CTW: 32 ms
 818          *  PM_SLEEP_TIME_CTW_64MS           CTW: 64 ms
 819          *  PM_SLEEP_TIME_CTW_128MS          CTW: 128 ms
 820          *  PM_SLEEP_TIME_CTW_256MS          CTW: 256 ms
 821          *  PM_SLEEP_TIME_CTW_512MS          CTW: 512 ms
 822          *  PM_SLEEP_TIME_CTW_1024MS         CTW: 1024 ms
 823          *  PM_SLEEP_TIME_CTW_2048MS         CTW: 2048 ms
 824          *  PM_SLEEP_TIME_CTW_4096MS         CTW: 4096 ms
 825          *
 826          *  wakeUpSource:    Specifies a bitwise mask of wakeup sources. In addition, if
 827          *                   a wakeupTime has been specified the associated timer will be
 828          *                   included as a wakeup source. For PSoC 5 this parameter is
 829          *                   ignored.
 830          *
 831          *           Define                      Source
 832          *  PM_SLEEP_SRC_NONE                None
 833          *  PM_SLEEP_SRC_COMPARATOR0         Comparator 0
 834          *  PM_SLEEP_SRC_COMPARATOR1         Comparator 1
 835          *  PM_SLEEP_SRC_COMPARATOR2         Comparator 2
 836          *  PM_SLEEP_SRC_COMPARATOR3         Comparator 3
 837          *  PM_SLEEP_SRC_PICU                PICU
 838          *  PM_SLEEP_SRC_I2C                 I2C
 839          *  PM_SLEEP_SRC_BOOSTCONVERTER      Boost Converter
 840          *  PM_SLEEP_SRC_VD                  High and Low Voltage Detection (HVI, LVI)
 841          *  PM_SLEEP_SRC_CTW                 Central Timewheel*
 842          *  PM_SLEEP_SRC_ONE_PPS             One PPS*
 843          *  PM_SLEEP_SRC_LCD                 LCD
 844          *
 845          *  *Note:   CTW and One PPS wakeup signals are in the same mask bit.
 846          *           For PSoC 5, these are in a different bit (value 1024).
 847          *
 848          *  When specifying a Comparator as the wakeupSource an instance specific define
 849          *  should be used that will track with the specific comparator that the instance
 850          *  is placed into. As an example for a Comparator instance named MyComp the
 851          *  value to OR into the mask is: MyComp_ctComp__CMP_MASK.
 852          *
 853          *  When CTW or One PPS is used as a wakeup source, the CyPmReadStatus()
 854          *  function must be called upon wakeup with corresponding parameter. Please
 855          *  refer to the CyPmReadStatus() API in the System Reference Guide for more
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 15  

 856          *  information.
 857          *
 858          * Return:
 859          *  None
 860          *
 861          * Reentrant:
 862          *  No
 863          *
 864          * Side Effects:
 865          *  For PSoC 5 silicon the wakeup source is not selectable. In this case the
 866          *  wakeupSource argument is ignored and any of the available wakeup sources will
 867          *  wake the device.
 868          *
 869          *  If a wakeupTime other than NONE is specified, then upon exit the state of the
 870          *  specified timer will be left as specified by wakeupTime with the timer
 871          *  enabled and the interrupt disabled. Also, the ILO 1 KHz (if CTW timer is
 872          *  used as wake up time) will be left started.
 873          *
 874          *  The 1 kHz ILO clock is expected to be enabled for PSoC 3 and PSoC 5LP to
 875          *  measure Hibernate/Sleep regulator settling time after a reset. The holdoff
 876          *  delay is measured using rising edges of the 1 kHz ILO.
 877          *
 878          *******************************************************************************/
 879          void CyPmSleep(uint8 wakeupTime, uint16 wakeupSource) 
 880          {
 881   1          uint8 interruptState;
 882   1      
 883   1          /* Save current global interrupt enable and disable it */
 884   1          interruptState = CyEnterCriticalSection();
 885   1      
 886   1      
 887   1          #if(CY_PSOC3 || CY_PSOC5LP)
 888   1      
 889   1              /***********************************************************************
 890   1              * The Hibernate/Sleep regulator has a settling time after a reset.
 891   1              * During this time, the system ignores requests to enter Sleep and
 892   1              * Hibernate modes. The holdoff delay is measured using rising edges of
 893   1              * the 1 kHz ILO.
 894   1              ***********************************************************************/
 895   1              if(0u == (CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_PWRUP_PULSE_Q))
 896   1              {
 897   2                  /* Disable hold off - no action on restore */
 898   2                  CY_PM_PWRSYS_SLP_TR_REG &= CY_PM_PWRSYS_SLP_TR_HIBSLP_HOLDOFF_MASK;
 899   2              }
 900   1              else
 901   1              {
 902   2                  /* Abort, device is not ready for low power mode entry */
 903   2      
 904   2                  /* Restore global interrupt enable state */
 905   2                  CyExitCriticalSection(interruptState);
 906   2      
 907   2                  return;
 908   2              }
 909   1      
 910   1          #endif /* (CY_PSOC3 || CY_PSOC5LP) */
 911   1      
 912   1      
 913   1          #if(CY_PSOC3)
 914   1      
 915   1              /* Hardware buzz expected to be disabled below for TO6 */
 916   1              if(CYDEV_CHIP_REV_ACTUAL < 5u)
 917   1              {
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 16  

 918   2                  CYASSERT(0u == (CY_PM_PWRSYS_WAKE_TR2_REG & CY_PM_PWRSYS_WAKE_TR2_EN_BUZZ));
 919   2              }
 920   1      
 921   1          #endif /* (CY_PSOC3) */
 922   1      
 923   1      
 924   1          /*******************************************************************************
 925   1          * For ARM-based devices, an interrupt is required for the CPU to wake up. The
 926   1          * Power Management implementation assumes that wakeup time is configured with a
 927   1          * separate component (component-based wakeup time configuration) for an
 928   1          * interrupt to be issued on terminal count. For more information, refer to the
 929   1          * Wakeup Time Configuration section of System Reference Guide.
 930   1          *******************************************************************************/
 931   1          #if(CY_PSOC5)
              
                      /* Arguments expected to be 0 */
                      CYASSERT(PM_SLEEP_TIME_NONE == wakeupTime);
              
                      #if(CY_PSOC5A)
              
                          /* The wakeupSource argument expected to be 0 */
                          CYASSERT(PM_SLEEP_SRC_NONE  == wakeupSource);
              
                          if(0u != wakeupSource)
                          {
                              /* To remove unreferenced local variable warning */
                          }
              
                      #endif /* (CY_PSOC5A) */
              
                      if(0u != wakeupTime)
                      {
                          /* To remove unreferenced local variable warning */
                      }
              
                  #endif /* (CY_PSOC5) */
 954   1      
 955   1      
 956   1          /* Prepare hardware for Sleep mode */
 957   1          CyPmSlpSaveSet();
 958   1      
 959   1      
 960   1          #if(CY_PSOC3)
 961   1      
 962   1              /* CTW - save current and set new configuration */
 963   1              if((wakeupTime >= PM_SLEEP_TIME_CTW_2MS) && (wakeupTime <= PM_SLEEP_TIME_CTW_4096MS))
 964   1              {
 965   2                  /* Save current and set new configuration of the CTW */
 966   2                  CyPmCtwSetInterval((uint8)(wakeupTime - 1u));
 967   2      
 968   2                  /* Include associated timer to the wakeupSource */
 969   2                  wakeupSource |= PM_SLEEP_SRC_CTW;
 970   2              }
 971   1      
 972   1              /* 1PPS - save current and set new configuration */
 973   1              if(PM_SLEEP_TIME_ONE_PPS == wakeupTime)
 974   1              {
 975   2                  /* Save current and set new configuration of the 1PPS */
 976   2                  CyPmOppsSet();
 977   2      
 978   2                  /* Include associated timer to the wakeupSource */
 979   2                  wakeupSource |= PM_SLEEP_SRC_ONE_PPS;
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 17  

 980   2              }
 981   1      
 982   1          #endif /* (CY_PSOC3) */
 983   1      
 984   1      
 985   1          #if(!CY_PSOC5A)
 986   1      
 987   1              /* Save and set new wake up configuration */
 988   1      
 989   1              /* Interrupt, PICU, I2C, Boost converter, CTW/1PPS */
 990   1              cyPmBackup.wakeupCfg0 = CY_PM_WAKEUP_CFG0_REG;
 991   1              CY_PM_WAKEUP_CFG0_REG = (uint8) (wakeupSource >> 4u);
 992   1      
 993   1              /* Comparators */
 994   1              cyPmBackup.wakeupCfg1 = CY_PM_WAKEUP_CFG1_REG;
 995   1              CY_PM_WAKEUP_CFG1_REG = (((uint8) wakeupSource) & CY_PM_WAKEUP_SRC_CMPS_MASK);
 996   1      
 997   1              /* LCD */
 998   1              cyPmBackup.wakeupCfg2 = CY_PM_WAKEUP_CFG2_REG;
 999   1              CY_PM_WAKEUP_CFG2_REG = ((uint8) ((wakeupSource >> 12u) & 0x01u));
1000   1      
1001   1          #endif /* (!CY_PSOC5A) */
1002   1      
1003   1      
1004   1          /*******************************************************************
1005   1          * Do not use merge region below unless any component datasheet
1006   1          * suggest to do so.
1007   1          *******************************************************************/
1008   1          /* `#START CY_PM_JUST_BEFORE_SLEEP` */
1009   1      
1010   1          /* `#END` */
1011   1      
1012   1      
1013   1          /* Last moment IMO frequency change */
1014   1          if(0u == (CY_PM_FASTCLK_IMO_CR_REG & CY_PM_FASTCLK_IMO_CR_FREQ_MASK))
1015   1          {
1016   2              /* IMO frequency is 12 MHz */
1017   2              cyPmBackup.imoActFreq12Mhz = CY_PM_ENABLED;
1018   2          }
1019   1          else
1020   1          {
1021   2              /* IMO frequency is not 12 MHz */
1022   2              cyPmBackup.imoActFreq12Mhz = CY_PM_DISABLED;
1023   2      
1024   2              /* Save IMO frequency */
1025   2              cyPmBackup.imoActFreq = CY_PM_FASTCLK_IMO_CR_REG & CY_PM_FASTCLK_IMO_CR_FREQ_MASK;
1026   2      
1027   2              /* Set IMO frequency to 12 MHz */
1028   2              CY_PM_FASTCLK_IMO_CR_REG &= ((uint8) (~CY_PM_FASTCLK_IMO_CR_FREQ_MASK));
1029   2          }
1030   1      
1031   1          /* Switch to the Sleep mode */
1032   1          CY_PM_MODE_CSR_REG = ((CY_PM_MODE_CSR_REG & ((uint8)(~CY_PM_MODE_CSR_MASK))) | CY_PM_MODE_CSR_SLEEP);
1033   1      
1034   1          /* Recommended readback. */
1035   1          (void) CY_PM_MODE_CSR_REG;
1036   1      
1037   1          /* Two recommended NOPs to get into the mode. */
1038   1          CY_NOP;
1039   1          CY_NOP;
1040   1      
1041   1          /* Execute WFI instruction (for ARM-based devices only) */
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 18  

1042   1          CY_PM_WFI;
1043   1      
1044   1          /* Point of return from Sleep Mode */
1045   1      
1046   1          /* Restore last moment IMO frequency change */
1047   1          if(CY_PM_ENABLED != cyPmBackup.imoActFreq12Mhz)
1048   1          {
1049   2              CY_PM_FASTCLK_IMO_CR_REG  = (CY_PM_FASTCLK_IMO_CR_REG & ((uint8)(~CY_PM_FASTCLK_IMO_CR_FREQ_MASK))
             -) |
1050   2                                          cyPmBackup.imoActFreq;
1051   2          }
1052   1      
1053   1      
1054   1          /*******************************************************************
1055   1          * Do not use merge region below unless any component datasheet
1056   1          * suggest to do so.
1057   1          *******************************************************************/
1058   1          /* `#START CY_PM_JUST_AFTER_WAKEUP_FROM_SLEEP` */
1059   1      
1060   1          /* `#END` */
1061   1      
1062   1      
1063   1          /* Restore hardware configuration */
1064   1          CyPmSlpRestore();
1065   1      
1066   1      
1067   1          #if(!CY_PSOC5A)
1068   1      
1069   1              /* Restore current wake up configuration */
1070   1              CY_PM_WAKEUP_CFG0_REG = cyPmBackup.wakeupCfg0;
1071   1              CY_PM_WAKEUP_CFG1_REG = cyPmBackup.wakeupCfg1;
1072   1              CY_PM_WAKEUP_CFG2_REG = cyPmBackup.wakeupCfg2;
1073   1      
1074   1          #endif /* (!CY_PSOC5A) */
1075   1      
1076   1          /* Restore global interrupt enable state */
1077   1          CyExitCriticalSection(interruptState);
1078   1      }
1079          
1080          
1081          /*******************************************************************************
1082          * Function Name: CyPmHibernate
1083          ********************************************************************************
1084          *
1085          * Summary:
1086          *  Puts the part into the Hibernate state.
1087          *
1088          *  PSoC 3 and PSoC 5LP:
1089          *  Before switching to Hibernate, the current status of the PICU wakeup source
1090          *  bit is saved and then set. This configures the device to wake up from the
1091          *  PICU. Make sure you have at least one pin configured to generate a PICU
1092          *  interrupt. For pin Px.y, the register "PICU_INTTYPE_PICUx_INTTYPEy" controls
1093          *  the PICU behavior. In the TRM, this register is "PICU[0..15]_INTTYPE[0..7]."
1094          *  In the Pins component datasheet, this register is referred to as the IRQ
1095          *  option. Once the wakeup occurs, the PICU wakeup source bit is restored and
1096          *  the PSoC returns to the Active state.
1097          *
1098          *  PSoC 5:
1099          *  The only method supported for waking up from the Hibernate state is a
1100          *  hardware reset of the device.  The PICU wakeup source cannot be used
1101          *  reliably, so the PICU interrupt sources are automatically disabled by this
1102          *  function before putting the device into the Hibernate state.
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 19  

1103          *
1104          * Parameters:
1105          *  None
1106          *
1107          * Return:
1108          *  None
1109          *
1110          * Reentrant:
1111          *  No
1112          *
1113          * Side Effects:
1114          *  Applications must wait 20 us before re-entering hibernate or sleep after
1115          *  waking up from hibernate. The 20 us allows the sleep regulator time to
1116          *  stabilize before the next hibernate / sleep event occurs. The 20 us
1117          *  requirement begins when the device wakes up. There is no hardware check that
1118          *  this requirement is met. The specified delay should be done on ISR entry.
1119          *
1120          *  After wakeup PICU interrupt occurs, the Pin_ClearInterrupt() (where Pin is
1121          *  instance name of the Pins component) function must be called to clear the
1122          *  latched pin events to allow proper Hibernate mode entry andd to enable
1123          *  detection of future events.
1124          *
1125          *  The 1 kHz ILO clock is expected to be enabled for PSoC 3 and PSoC 5LP to
1126          *  measure Hibernate/Sleep regulator settling time after a reset. The holdoff
1127          *  delay is measured using rising edges of the 1 kHz ILO.
1128          *
1129          *******************************************************************************/
1130          void CyPmHibernate(void) 
1131          {
1132   1          uint8 interruptState;
1133   1      
1134   1          /* Save current global interrupt enable and disable it */
1135   1          interruptState = CyEnterCriticalSection();
1136   1      
1137   1          #if(CY_PSOC3 || CY_PSOC5LP)
1138   1      
1139   1              /***********************************************************************
1140   1              * The Hibernate/Sleep regulator has a settling time after a reset.
1141   1              * During this time, the system ignores requests to enter Sleep and
1142   1              * Hibernate modes. The holdoff delay is measured using rising edges of
1143   1              * the 1 kHz ILO.
1144   1              ***********************************************************************/
1145   1              if(0u == (CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_PWRUP_PULSE_Q))
1146   1              {
1147   2                  /* Disable hold off - no action on restore */
1148   2                  CY_PM_PWRSYS_SLP_TR_REG &= CY_PM_PWRSYS_SLP_TR_HIBSLP_HOLDOFF_MASK;
1149   2              }
1150   1              else
1151   1              {
1152   2                  /* Abort, device is not ready for low power mode entry */
1153   2      
1154   2                  /* Restore global interrupt enable state */
1155   2                  CyExitCriticalSection(interruptState);
1156   2      
1157   2                  return;
1158   2              }
1159   1      
1160   1          #endif /* (CY_PSOC3 || CY_PSOC5LP) */
1161   1      
1162   1          /* Prepare device for proper Hibernate mode entry */
1163   1          CyPmHibSaveSet();
1164   1      
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 20  

1165   1      
1166   1          #if(!CY_PSOC5A)
1167   1      
1168   1              /* Save and enable only wakeup on PICU */
1169   1              cyPmBackup.wakeupCfg0 = CY_PM_WAKEUP_CFG0_REG;
1170   1              CY_PM_WAKEUP_CFG0_REG = CY_PM_WAKEUP_PICU;
1171   1      
1172   1              cyPmBackup.wakeupCfg1 = CY_PM_WAKEUP_CFG1_REG;
1173   1              CY_PM_WAKEUP_CFG1_REG = 0x00u;
1174   1      
1175   1              cyPmBackup.wakeupCfg2 = CY_PM_WAKEUP_CFG2_REG;
1176   1              CY_PM_WAKEUP_CFG2_REG = 0x00u;
1177   1      
1178   1          #endif  /* (!CY_PSOC5A) */
1179   1      
1180   1      
1181   1          /* Last moment IMO frequency change */
1182   1          if(0u == (CY_PM_FASTCLK_IMO_CR_REG & CY_PM_FASTCLK_IMO_CR_FREQ_MASK))
1183   1          {
1184   2              /* IMO frequency is 12 MHz */
1185   2              cyPmBackup.imoActFreq12Mhz = CY_PM_ENABLED;
1186   2          }
1187   1          else
1188   1          {
1189   2              /* IMO frequency is not 12 MHz */
1190   2              cyPmBackup.imoActFreq12Mhz = CY_PM_DISABLED;
1191   2      
1192   2              /* Save IMO frequency */
1193   2              cyPmBackup.imoActFreq = CY_PM_FASTCLK_IMO_CR_REG & CY_PM_FASTCLK_IMO_CR_FREQ_MASK;
1194   2      
1195   2              /* Set IMO frequency to 12 MHz */
1196   2              CY_PM_FASTCLK_IMO_CR_REG &= ((uint8) (~CY_PM_FASTCLK_IMO_CR_FREQ_MASK));
1197   2          }
1198   1      
1199   1      
1200   1          /* Switch to Hibernate Mode */
1201   1          CY_PM_MODE_CSR_REG = (CY_PM_MODE_CSR_REG & ((uint8) (~CY_PM_MODE_CSR_MASK))) | CY_PM_MODE_CSR_HIBERNAT
             -E;
1202   1      
1203   1          /* Recommended readback. */
1204   1          (void) CY_PM_MODE_CSR_REG;
1205   1      
1206   1          /* Two recommended NOPs to get into the mode. */
1207   1          CY_NOP;
1208   1          CY_NOP;
1209   1      
1210   1          /* Execute WFI instruction (for ARM-based devices only) */
1211   1          CY_PM_WFI;
1212   1      
1213   1          /* Point of return from Hibernate mode */
1214   1      
1215   1      
1216   1          /* Restore last moment IMO frequency change */
1217   1          if(CY_PM_ENABLED != cyPmBackup.imoActFreq12Mhz)
1218   1          {
1219   2              CY_PM_FASTCLK_IMO_CR_REG  = (CY_PM_FASTCLK_IMO_CR_REG & ((uint8)(~CY_PM_FASTCLK_IMO_CR_FREQ_MASK))
             -) |
1220   2                                          cyPmBackup.imoActFreq;
1221   2          }
1222   1      
1223   1      
1224   1          /* Restore device for proper Hibernate mode exit*/
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 21  

1225   1          CyPmHibRestore();
1226   1      
1227   1      
1228   1          #if(!CY_PSOC5A)
1229   1      
1230   1              /* Restore current wake up configuration */
1231   1              CY_PM_WAKEUP_CFG0_REG = cyPmBackup.wakeupCfg0;
1232   1              CY_PM_WAKEUP_CFG1_REG = cyPmBackup.wakeupCfg1;
1233   1              CY_PM_WAKEUP_CFG2_REG = cyPmBackup.wakeupCfg2;
1234   1      
1235   1          #endif /* (!CY_PSOC5A) */
1236   1      
1237   1          /* Restore global interrupt enable state */
1238   1          CyExitCriticalSection(interruptState);
1239   1      }
1240          
1241          
1242          /*******************************************************************************
1243          * Function Name: CyPmReadStatus
1244          ********************************************************************************
1245          *
1246          * Summary:
1247          *  Manages the Power Manager Interrupt Status Register.  This register has the
1248          *  interrupt status for the one pulse per second, central timewheel and fast
1249          *  timewheel timers.  This hardware register clears on read.  To allow for only
1250          *  clearing the bits of interest and preserving the other bits, this function
1251          *  uses a shadow register that retains the state.  This function reads the
1252          *  status register and ORs that value with the shadow register.  That is the
1253          *  value that is returned.  Then the bits in the mask that are set are cleared
1254          *  from this value and written back to the shadow register.
1255          *
1256          *  Note You must call this function within 1 ms (1 clock cycle of the ILO)
1257          *  after a CTW event has occurred.
1258          *
1259          * Parameters:
1260          *  mask: Bits in the shadow register to clear.
1261          *
1262          *       Define                      Source
1263          *  CY_PM_FTW_INT                Fast Timewheel
1264          *  CY_PM_CTW_INT                Central Timewheel
1265          *  CY_PM_ONEPPS_INT             One Pulse Per Second
1266          *
1267          * Return:
1268          *  Status.  Same bits values as the mask parameter.
1269          *
1270          *******************************************************************************/
1271          uint8 CyPmReadStatus(uint8 mask) CYREENTRANT
1272          {
1273   1          static uint8 interruptStatus;
1274   1          uint8 interruptState;
1275   1          uint8 tmpStatus;
1276   1      
1277   1          /* Enter critical section */
1278   1          interruptState = CyEnterCriticalSection();
1279   1      
1280   1          /* Save value of the register, copy it and clear desired bit */
1281   1          interruptStatus |= CY_PM_INT_SR_REG;
1282   1          tmpStatus = interruptStatus;
1283   1          interruptStatus &= ((uint8)(~mask));
1284   1      
1285   1          /* Exit critical section */
1286   1          CyExitCriticalSection(interruptState);
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 22  

1287   1      
1288   1          return(tmpStatus);
1289   1      }
1290          
1291          
1292          /*******************************************************************************
1293          * Function Name: CyPmHibSaveSet
1294          ********************************************************************************
1295          *
1296          * Summary:
1297          *  Prepare device for proper Hibernate low power mode entry:
1298          *  - Disables I2C backup regulator
1299          *  - Save state of I2C backup regulator (PSoC 5)
1300          *  - Saves ILO power down mode state and enable it (all but PSoC 5)
1301          *  - Saves state of 1 kHz and 100 kHz ILO and disable them (all but PSoC 5)
1302          *  - Disables sleep regulator and shorts vccd to vpwrsleep (all but PSoC 5)
1303          *  - Save LVI/HVI configuration and disable them - CyPmHviLviSaveDisable()
1304          *  - CyPmHibSlpSaveSet() function is called
1305          *
1306          * Parameters:
1307          *  None
1308          *
1309          * Return:
1310          *  None
1311          *
1312          * Reentrant:
1313          *  No
1314          *
1315          *******************************************************************************/
1316          static void CyPmHibSaveSet(void) 
1317          {
1318   1          /* I2C backup reg must be off when the sleep regulator is unavailable */
1319   1          if(0u != (CY_PM_PWRSYS_CR1_REG & CY_PM_PWRSYS_CR1_I2CREG_BACKUP))
1320   1          {
1321   2              /***********************************************************************
1322   2              * If I2C backup regulator is enabled, all the fixed-function registers
1323   2              * store their values while device is in low power mode, otherwise their
1324   2              * configuration is lost. The I2C API makes a decision to restore or not
1325   2              * to restore I2C registers based on this. If this regulator will be
1326   2              * disabled and then enabled, I2C API will suppose that I2C block
1327   2              * registers preserved their values, while this is not true. So, the
1328   2              * backup regulator is disabled. And its value is restored only for
1329   2              * and PSoC 5 devices. The I2C sleep APIs is responsible for restoration.
1330   2              ***********************************************************************/
1331   2      
1332   2              #if(CY_PSOC5A)
              
                          cyPmBackup.i2cRegBackup = CY_PM_ENABLED;
              
                      #endif /* (CY_PSOC5A) */
1337   2      
1338   2              /* Disable I2C backup register */
1339   2              CY_PM_PWRSYS_CR1_REG &= ((uint8)(~CY_PM_PWRSYS_CR1_I2CREG_BACKUP));
1340   2          }
1341   1          else
1342   1          {
1343   2              #if(CY_PSOC5A)
              
                          /* Save disabled state of the I2C backup regulator */
                          cyPmBackup.i2cRegBackup = CY_PM_DISABLED;
              
                      #endif /* (CY_PSOC5A) */
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 23  

1349   2          }
1350   1      
1351   1      
1352   1          #if(!CY_PSOC5A)
1353   1      
1354   1              /* Save current ILO power mode and ensure low power mode */
1355   1              cyPmBackup.iloPowerMode = CyILO_SetPowerMode(CY_PM_POWERDOWN_MODE);
1356   1      
1357   1              /* Save current 1kHz ILO enable state. Disabled automatically. */
1358   1              cyPmBackup.ilo1kEnable = (0u == (CY_PM_SLOWCLK_ILO_CR0_REG & CY_PM_ILO_CR0_EN_1K)) ?
1359   1                                          CY_PM_DISABLED : CY_PM_ENABLED;
1360   1      
1361   1              /* Save current 100kHz ILO enable state. Disabled automatically. */
1362   1              cyPmBackup.ilo100kEnable = (0u == (CY_PM_SLOWCLK_ILO_CR0_REG & CY_PM_ILO_CR0_EN_100K)) ?
1363   1                                          CY_PM_DISABLED : CY_PM_ENABLED;
1364   1      
1365   1      
1366   1              /* Disable the sleep regulator and shorts vccd to vpwrsleep */
1367   1              if(0u == (CY_PM_PWRSYS_SLP_TR_REG & CY_PM_PWRSYS_SLP_TR_BYPASS))
1368   1              {
1369   2                  /* Save current bypass state */
1370   2                  cyPmBackup.slpTrBypass = CY_PM_DISABLED;
1371   2                  CY_PM_PWRSYS_SLP_TR_REG |= CY_PM_PWRSYS_SLP_TR_BYPASS;
1372   2              }
1373   1              else
1374   1              {
1375   2                  cyPmBackup.slpTrBypass = CY_PM_ENABLED;
1376   2              }
1377   1      
1378   1              /* LPCOMPs are always enabled (even when BOTH ext_vccd=1 and ext_vcca=1)*/
1379   1      
1380   1          #endif /* (!CY_PSOC5A) */
1381   1      
1382   1      
1383   1          /* Device is PSoC 5 and the revision is ES1 or earlier. */
1384   1          #if(CY_PSOC5A)
              
                      /* Disable all the PICU interrupts */
                      CyPmDisablePicuInterrupts();
              
                  #endif  /* (CY_PSOC5A) */
1390   1      
1391   1      
1392   1          /***************************************************************************
1393   1          * LVI/HVI must be disabled in Hibernate
1394   1          ***************************************************************************/
1395   1      
1396   1          /* Save LVI/HVI configuration and disable them */
1397   1          CyPmHviLviSaveDisable();
1398   1      
1399   1      
1400   1          /* Make the same preparations for Hibernate and Sleep modes */
1401   1          CyPmHibSlpSaveSet();
1402   1      }
1403          
1404          
1405          /*******************************************************************************
1406          * Function Name: CyPmHibRestore
1407          ********************************************************************************
1408          *
1409          * Summary:
1410          *  Restore device for proper Hibernate mode exit:
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 24  

1411          *  - Restore LVI/HVI configuration - call CyPmHviLviRestore()
1412          *  - CyPmHibSlpSaveRestore() function is called
1413          *  - Restores state of I2C backup regulator (PSoC 5)
1414          *  - Restores ILO power down mode state and enable it (all but PSoC 5)
1415          *  - Restores state of 1 kHz and 100 kHz ILO and disable them (all but PSoC 5)
1416          *  - Restores sleep regulator settings (all but PSoC 5)
1417          *
1418          * Parameters:
1419          *  None
1420          *
1421          * Return:
1422          *  None
1423          *
1424          *******************************************************************************/
1425          static void CyPmHibRestore(void) 
1426          {
1427   1          /* Restore LVI/HVI configuration */
1428   1          CyPmHviLviRestore();
1429   1      
1430   1          /* Restore the same configuration for Hibernate and Sleep modes */
1431   1          CyPmHibSlpRestore();
1432   1      
1433   1          #if(CY_PSOC5A)
              
                      /* Restore I2C backup regulator configuration */
                      if(CY_PM_ENABLED == cyPmBackup.i2cRegBackup)
                      {
                          /* Enable I2C backup regulator state */
                          CY_PM_PWRSYS_CR1_REG |= CY_PM_PWRSYS_CR1_I2CREG_BACKUP;
                      }
              
                  #endif /* (CY_PSOC5A) */
1443   1      
1444   1      
1445   1          #if(!CY_PSOC5A)
1446   1      
1447   1              /* Restore 1kHz ILO enable state */
1448   1              if(CY_PM_ENABLED == cyPmBackup.ilo1kEnable)
1449   1              {
1450   2                  /* Enable 1kHz ILO */
1451   2                  CyILO_Start1K();
1452   2              }
1453   1      
1454   1              /* Restore 100kHz ILO enable state */
1455   1              if(CY_PM_ENABLED == cyPmBackup.ilo100kEnable)
1456   1              {
1457   2                  /* Enable 100kHz ILO */
1458   2                  CyILO_Start100K();
1459   2              }
1460   1      
1461   1              /* Restore ILO power mode */
1462   1              (void) CyILO_SetPowerMode(cyPmBackup.iloPowerMode);
1463   1      
1464   1      
1465   1              if(CY_PM_DISABLED == cyPmBackup.slpTrBypass)
1466   1              {
1467   2                  /* Enable the sleep regulator */
1468   2                  CY_PM_PWRSYS_SLP_TR_REG &= ((uint8)(~CY_PM_PWRSYS_SLP_TR_BYPASS));
1469   2              }
1470   1      
1471   1          #endif /* (!CY_PSOC5A) */
1472   1      }
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 25  

1473          
1474          
1475          /*******************************************************************************
1476          * Function Name: CyPmCtwSetInterval
1477          ********************************************************************************
1478          *
1479          * Summary:
1480          *  Performs CTW configuration:
1481          *  - Disables CTW interrupt
1482          *  - Enables 1 kHz ILO
1483          *  - Sets new CTW interval
1484          *
1485          * Parameters:
1486          *  ctwInterval: the CTW interval to be set.
1487          *
1488          * Return:
1489          *  None
1490          *
1491          * Side Effects:
1492          *  Enables ILO 1 KHz clock and leaves it enabled.
1493          *
1494          *******************************************************************************/
1495          void CyPmCtwSetInterval(uint8 ctwInterval) 
1496          {
1497   1          /* Disable CTW interrupt enable */
1498   1          CY_PM_TW_CFG2_REG &= ((uint8)(~CY_PM_CTW_IE));
1499   1      
1500   1          /* Enable 1kHz ILO (required for CTW operation) */
1501   1          CyILO_Start1K();
1502   1      
1503   1          /* Interval could be set only while CTW is disabled */
1504   1          if(0u != (CY_PM_TW_CFG2_REG & CY_PM_CTW_EN))
1505   1          {
1506   2              /* Set CTW interval if needed */
1507   2              if(CY_PM_TW_CFG1_REG != ctwInterval)
1508   2              {
1509   3                  /* Disable the CTW, set new CTW interval and enable it again */
1510   3                  CY_PM_TW_CFG2_REG &= ((uint8)(~CY_PM_CTW_EN));
1511   3                  CY_PM_TW_CFG1_REG = ctwInterval;
1512   3                  CY_PM_TW_CFG2_REG |= CY_PM_CTW_EN;
1513   3              }   /* Required interval is already set */
1514   2          }
1515   1          else
1516   1          {
1517   2              /* Set CTW interval if needed */
1518   2              if(CY_PM_TW_CFG1_REG != ctwInterval)
1519   2              {
1520   3                  /* Set the new CTW interval. Could be changed if CTW is disabled */
1521   3                  CY_PM_TW_CFG1_REG = ctwInterval;
1522   3              }   /* Required interval is already set */
1523   2      
1524   2              /* Enable the CTW */
1525   2              CY_PM_TW_CFG2_REG |= CY_PM_CTW_EN;
1526   2          }
1527   1      }
1528          
1529          
1530          /*******************************************************************************
1531          * Function Name: CyPmOppsSet
1532          ********************************************************************************
1533          *
1534          * Summary:
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 26  

1535          *  Performs 1PPS configuration:
1536          *  - Starts 32 KHz XTAL
1537          *  - Disables 1PPS interupts
1538          *  - Enables 1PPS
1539          *
1540          * Parameters:
1541          *  None
1542          *
1543          * Return:
1544          *  None
1545          *
1546          *******************************************************************************/
1547          void CyPmOppsSet(void) 
1548          {
1549   1          /* Enable 32kHz XTAL if needed */
1550   1          if(0u == (CY_PM_SLOWCLK_X32_CR_REG & CY_PM_X32_CR_X32EN))
1551   1          {
1552   2              /* Enable 32kHz XTAL */
1553   2              CyXTAL_32KHZ_Start();
1554   2          }
1555   1      
1556   1          /* Disable 1PPS interrupt enable */
1557   1          CY_PM_TW_CFG2_REG &= ((uint8)(~CY_PM_1PPS_IE));
1558   1      
1559   1          /* Enable 1PPS operation */
1560   1          CY_PM_TW_CFG2_REG |= CY_PM_1PPS_EN;
1561   1      }
1562          
1563          
1564          /*******************************************************************************
1565          * Function Name: CyPmFtwSetInterval
1566          ********************************************************************************
1567          *
1568          * Summary:
1569          *  Performs FTW configuration:
1570          *  - Disables FTW interrupt
1571          *  - Enables 100 kHz ILO
1572          *  - Sets new FTW interval.
1573          *
1574          * Parameters:
1575          *  ftwInterval - FTW counter interval.
1576          *
1577          * Return:
1578          *  None
1579          *
1580          * Side Effects:
1581          *  Enables ILO 100 KHz clock and leaves it enabled.
1582          *
1583          *******************************************************************************/
1584          void CyPmFtwSetInterval(uint8 ftwInterval) 
1585          {
1586   1          /* Disable FTW interrupt enable */
1587   1          CY_PM_TW_CFG2_REG &= ((uint8)(~CY_PM_FTW_IE));
1588   1      
1589   1          /* Enable 100kHz ILO */
1590   1          CyILO_Start100K();
1591   1      
1592   1          /* Iterval could be set only while FTW is disabled */
1593   1          if(0u != (CY_PM_TW_CFG2_REG & CY_PM_FTW_EN))
1594   1          {
1595   2              /* Disable FTW, set new FTW interval if needed and enable it again */
1596   2              if(CY_PM_TW_CFG0_REG != ftwInterval)
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 27  

1597   2              {
1598   3                  /* Disable the CTW, set new CTW interval and enable it again */
1599   3                  CY_PM_TW_CFG2_REG &= ((uint8)(~CY_PM_FTW_EN));
1600   3                  CY_PM_TW_CFG0_REG = ftwInterval;
1601   3                  CY_PM_TW_CFG2_REG |= CY_PM_FTW_EN;
1602   3              }   /* Required interval is already set */
1603   2          }
1604   1          else
1605   1          {
1606   2              /* Set new FTW counter interval if needed. FTW is disabled. */
1607   2              if(CY_PM_TW_CFG0_REG != ftwInterval)
1608   2              {
1609   3                  /* Set the new CTW interval. Could be changed if CTW is disabled */
1610   3                  CY_PM_TW_CFG0_REG = ftwInterval;
1611   3              }   /* Required interval is already set */
1612   2      
1613   2              /* Enable the FTW */
1614   2              CY_PM_TW_CFG2_REG |= CY_PM_FTW_EN;
1615   2          }
1616   1      }
1617          
1618          
1619          #if(CY_PSOC5A)
              
                  /*******************************************************************************
                  * Function Name: CyPmSavePicuInterrupts
                  ********************************************************************************
                  *
                  * Summary:
                  *  Saves PICU interrupt type registers to the backup structure.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Reentrant:
                  *  No
                  *
                  *******************************************************************************/
                  static void CyPmSavePicuInterrupts(void) 
                  {
                      /* Save all the PICU interrupt type */
                      (void) memcpy((void *) &cyPmBackup.picuIntType[0u],
                                    (void *) CY_PM_PICU_0_6_INT_BASE,
                                    CY_PM_PICU_0_6_INT_SIZE);
              
                      (void) memcpy((void *) &cyPmBackup.picuIntType[CY_PM_PICU_0_6_INT_SIZE],
                                    (void *) CY_PM_PICU_12_INT_BASE,
                                    CY_PM_PICU_12_INT_SIZE);
              
                      (void) memcpy((void *) &cyPmBackup.picuIntType[CY_PM_PICU_0_6_INT_SIZE + CY_PM_PICU_12_INT_SIZE],
                                    (void *) CY_PM_PICU_15_INT_BASE,
                                    CY_PM_PICU_15_INT_SIZE);
              
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyPmDisablePicuInterrupts
                  ********************************************************************************
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 28  

                  *
                  * Summary:
                  *  Disableds PICU interrupts.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  static void CyPmDisablePicuInterrupts(void) 
                  {
                      /* Disable all the PICU interrupts */
                      (void) memset((void *) CY_PM_PICU_0_6_INT_BASE, 0, CY_PM_PICU_0_6_INT_SIZE);
                      (void) memset((void *) CY_PM_PICU_12_INT_BASE,  0, CY_PM_PICU_12_INT_SIZE );
                      (void) memset((void *) CY_PM_PICU_15_INT_BASE,  0, CY_PM_PICU_15_INT_SIZE );
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyPmRestorePicuInterrupts
                  ********************************************************************************
                  *
                  * Summary:
                  *  Restores PICU interrupt type registers from the backup structure.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  static void CyPmRestorePicuInterrupts(void) 
                  {
                      /* Save all the PICU interrupt type */
                      (void) memcpy((void *) CY_PM_PICU_0_6_INT_BASE,
                                    (void *) &cyPmBackup.picuIntType[0u],
                                    CY_PM_PICU_0_6_INT_SIZE);
              
                      (void) memcpy((void *) CY_PM_PICU_12_INT_BASE,
                                    (void *) &cyPmBackup.picuIntType[CY_PM_PICU_0_6_INT_SIZE],
                                    CY_PM_PICU_12_INT_SIZE);
              
                      (void) memcpy((void *) CY_PM_PICU_15_INT_BASE,
                                    (void *) &cyPmBackup.picuIntType[CY_PM_PICU_0_6_INT_SIZE + CY_PM_PICU_12_INT_SIZE],
                                    CY_PM_PICU_15_INT_SIZE);
              
                  }
              
              #endif  /* (CY_PSOC5A) */
1711          
1712          
1713          /*******************************************************************************
1714          * Function Name: CyPmSlpSaveSet
1715          ********************************************************************************
1716          *
1717          * Summary:
1718          *  Prepare device for proper Sleep low power mode entry:
1719          *  - Prepare CTW for Sleep mode entry (PSoC 5)
1720          *    * Save timewheels configuration
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 29  

1721          *    * Disable FTW and 1PPS (enable and interrupt)
1722          *    * Reset CTW
1723          *    * Save and disable PICU interrupts (PSoC 5)
1724          *    * Save and disable PRES-A and PRES-D (PSoC 5)
1725          *  - Save and disable LVI/HVI configuration (PSoC 5)
1726          *  - Save and set to max buzz interval (PSoC 5)
1727          *  - If LVI/HVI is enabled than hardware buzz in required (PSoC 3):
1728          *    * Prepare wake trim registers
1729          *    * Disable LDO-A in proper way
1730          *  - If LVI/HVI is disabled than hardware buzz in not required (PSoC 3):
1731          *    * Disabled hardware buzz
1732          *  - CyPmHibSlpSaveSet() function is called
1733          *
1734          * Parameters:
1735          *  None
1736          *
1737          * Return:
1738          *  None
1739          *
1740          * Reentrant:
1741          *  No
1742          *
1743          *******************************************************************************/
1744          static void CyPmSlpSaveSet(void) 
1745          {
1746   1          #if(CY_PSOC5A)
              
                      /* Preserve the Timewheel Configuration Register 2 */
                      cyPmBackup.pmTwCfg2 = CY_PM_TW_CFG2_REG;
              
                      /*  Clear the enable and interrupt enables for the FTW and ONEPPS */
                      CY_PM_TW_CFG2_REG &= ((uint8)(~(CY_PM_FTW_IE | CY_PM_FTW_EN | CY_PM_1PPS_EN | CY_PM_1PPS_IE)));
              
                      /* Reset free-running CTW counter to 0 and held it there */
                      CY_PM_WDT_CFG_REG |= CY_PM_WDT_CFG_CTW_RESET;
              
                      /* Exit CTW counter reset state */
                      CY_PM_WDT_CFG_REG &= ((uint8)(~CY_PM_WDT_CFG_CTW_RESET));
              
                      /* Save and disable PICU interrupts  */
                      CyPmSavePicuInterrupts();
                      CyPmDisablePicuInterrupts();
              
                      /* Save and disable PRES-A and PRES-D */
                      cyPmBackup.pres1 = CY_PM_RESET_CR1_REG & CY_PM_RESET_CR1_DIS_PRES1;
                      cyPmBackup.pres2 = CY_PM_RESET_CR3_REG & CY_PM_RESET_CR3_DIS_PRES2;
                      CY_PM_RESET_CR1_REG &= ((uint8)(~CY_PM_RESET_CR1_DIS_PRES1));
                      CY_PM_RESET_CR3_REG &= ((uint8)(~CY_PM_RESET_CR3_DIS_PRES2));
              
                  #endif /* (CY_PSOC5A) */
1771   1      
1772   1      
1773   1          #if(CY_PSOC5A)
              
                      /***************************************************************************
                      * LVI/HVI must be disabled as it doesn't work during buzzing.
                      *
                      * Using hardware buzz in conjunction with other device wakeup sources
                      * can cause the device to lockup, halting further code execution. The
                      * hardware buzz provides power supply supervising capability in sleep.
                      * It is enabled by default and there is no way to disable it. So the buzz
                      * interval is set to maximum (512 ms). The CTW must be configured to wake up
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 30  

                      * at a rate less than hardware buzz interval.
                      ***************************************************************************/
              
                      /* Save and disable LVI/HVI */
                      CyPmHviLviSaveDisable();
              
                      /* Save buzz trim value */
                      cyPmBackup.buzzSleepTrim = CY_PM_PWRSYS_BUZZ_TR_REG & ((uint8)(~CY_PM_PWRSYS_BUZZ_TR_MASK));
              
                      /* Set buzz interval to maximum */
                      CY_PM_PWRSYS_BUZZ_TR_REG = CY_PM_PWRSYS_BUZZ_TR_512_TICKS |
                                                (CY_PM_PWRSYS_BUZZ_TR_REG & CY_PM_PWRSYS_BUZZ_TR_MASK);
              
                  #endif  /* (CY_PSOC5A) */
1797   1      
1798   1      
1799   1          #if(CY_PSOC3)
1800   1      
1801   1              /***************************************************************************
1802   1              * If LVI/HVI is enabled than hardware buzz in required:
1803   1              *  - Prepare wake trim registers
1804   1              *  - Disable LDO-A in proper way
1805   1              *
1806   1              * If LVI/HVI is disabled than hardware buzz in not required:
1807   1              *  - Disabled hardware buzz
1808   1              ***************************************************************************/
1809   1      
1810   1              cyPmBackup.wakeTr2 = CY_PM_PWRSYS_WAKE_TR2_REG;
1811   1      
1812   1              /* Reconfigure power mode wakeup trim registers */
1813   1              if(0u != (CY_PM_RESET_CR1_REG & (CY_PM_RESET_CR1_HVIA_EN |
1814   1                        CY_PM_RESET_CR1_LVIA_EN | CY_PM_RESET_CR1_LVID_EN)))
1815   1              {
1816   2                  /* HVI/LVI is enabled - hardware buzz is required */
1817   2                  if(CYDEV_CHIP_REV_ACTUAL < 5u)
1818   2                  {
1819   3                      /* Update entire register */
1820   3                      CY_PM_PWRSYS_WAKE_TR2_REG = 0x3Bu;
1821   3      
1822   3                      /* Prepares for disabling LDO-A by moving bandgap reference to VCCD */
1823   3                      CY_PM_PWRSYS_CR1_REG = 0x01u;
1824   3      
1825   3                      /* Disables LDO-A */
1826   3                      CY_PM_PWRSYS_CR1_REG |= 0x02u;
1827   3                  }
1828   2                  else
1829   2                  {
1830   3                      /* For later revisions, just enable buzz */
1831   3                      CY_PM_PWRSYS_WAKE_TR2_REG |= CY_PM_PWRSYS_WAKE_TR2_EN_BUZZ;
1832   3                  }
1833   2              }
1834   1              else
1835   1              {
1836   2                  /* HVI/LVI is disabled - hardware buzz is not required */
1837   2                  if(CYDEV_CHIP_REV_ACTUAL < 5u)
1838   2                  {
1839   3                      /* Update entire register */
1840   3                      CY_PM_PWRSYS_WAKE_TR2_REG = 0x3Au;
1841   3                  }
1842   2              }
1843   1      
1844   1          #endif  /* (CY_PSOC3) */
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 31  

1845   1      
1846   1          /* Apply configuration that are same for Sleep and Hibernate */
1847   1          CyPmHibSlpSaveSet();
1848   1      }
1849          
1850          
1851          /*******************************************************************************
1852          * Function Name: CyPmSlpRestore
1853          ********************************************************************************
1854          *
1855          * Summary:
1856          *  Restore device for proper Sleep mode exit:
1857          *  - Restore timewheel configuration (PSoC 5)
1858          *  - Restore PRES-A and PRES-D (PSoC 5)
1859          *  - Restore PICU interrupts (PSoC 5)
1860          *  - Restore LVI/HVI configuration (PSoC 3)
1861          *  - Restore buzz sleep trim value (PSoC 5)
1862          *  - Call to CyPmHibSlpSaveRestore()
1863          *
1864          * Parameters:
1865          *  None
1866          *
1867          * Return:
1868          *  None
1869          *
1870          *******************************************************************************/
1871          static void CyPmSlpRestore(void) 
1872          {
1873   1          #if(CY_PSOC5A)
              
                      /* Restore the Timewheel Configuration Register 2 */
                      CY_PM_TW_CFG2_REG = cyPmBackup.pmTwCfg2;
              
                      /* Restore PICU interrupts */
                      CyPmRestorePicuInterrupts();
              
                      /* Restore PRES-A and PRES-D (assumed they were disabled) */
                      CY_PM_RESET_CR1_REG |= cyPmBackup.pres1;
                      CY_PM_RESET_CR3_REG |= cyPmBackup.pres2;
              
                  #endif /* (CY_PSOC5A) */
1886   1      
1887   1      
1888   1          #if(CY_PSOC5A)
              
                      /* Restore LVI/HVI configuration */
                      CyPmHviLviRestore();
              
                      /* Restore buzz sleep trim value */
                      CY_PM_PWRSYS_BUZZ_TR_REG = cyPmBackup.buzzSleepTrim |
                                                (CY_PM_PWRSYS_BUZZ_TR_REG & CY_PM_PWRSYS_BUZZ_TR_MASK);
              
                  #endif  /* (CY_PSOC5A) */
1898   1      
1899   1      
1900   1          #if(CY_PSOC3)
1901   1      
1902   1              CY_PM_PWRSYS_WAKE_TR2_REG = cyPmBackup.wakeTr2;
1903   1      
1904   1              /* HVI/LVI is enabled - hardware buzz is required */
1905   1              if(CYDEV_CHIP_REV_ACTUAL < 5u)
1906   1              {
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 32  

1907   2                  /* Reconfigure power mode wakeup trim registers */
1908   2                  if(0u != (CY_PM_RESET_CR1_REG & (CY_PM_RESET_CR1_HVIA_EN |
1909   2                            CY_PM_RESET_CR1_LVIA_EN | CY_PM_RESET_CR1_LVID_EN)))
1910   2                  {
1911   3                      /* Enables LDO-A */
1912   3                      CY_PM_PWRSYS_CR1_REG &= ((uint8)(~0x02u));
1913   3      
1914   3                      /* Moves bandgap reference back to VCCA */
1915   3                      CY_PM_PWRSYS_CR1_REG &= ((uint8)(~0x01u));
1916   3                  }
1917   2              }
1918   1      
1919   1          #endif  /* (CY_PSOC3) */
1920   1      
1921   1      
1922   1          /* Restore configuration that are same for Sleep and Hibernate */
1923   1          CyPmHibSlpRestore();
1924   1      }
1925          
1926          
1927          /*******************************************************************************
1928          * Function Name: CyPmHibSlpSaveSet
1929          ********************************************************************************
1930          *
1931          * Summary:
1932          *  This API is used for preparing device for Sleep and Hibernate low power
1933          *  modes entry:
1934          *  - Saves COMP, VIDAC, DSM and SAR routing connections (PSoC 5)
1935          *  - Saves SC/CT routing connections (PSoC 3/5/5LP)
1936          *  - Disables Serial Wire Viewer (SWV) (PSoC 3)
1937          *  - Save boost reference selection and set it to internal
1938          *
1939          * Parameters:
1940          *  None
1941          *
1942          * Return:
1943          *  None
1944          *
1945          * Reentrant:
1946          *  No
1947          *
1948          *******************************************************************************/
1949          static void CyPmHibSlpSaveSet(void) 
1950          {
1951   1          #if(CY_PSOC5A)
              
                      /* Save CMP routing registers */
                      cyPmBackup.cmpData[0u]  = CY_GET_REG8(CYREG_CMP0_SW0);
                      cyPmBackup.cmpData[1u]  = CY_GET_REG8(CYREG_CMP0_SW2);
                      cyPmBackup.cmpData[2u]  = CY_GET_REG8(CYREG_CMP0_SW3);
                      cyPmBackup.cmpData[3u]  = CY_GET_REG8(CYREG_CMP0_SW4);
                      cyPmBackup.cmpData[4u]  = CY_GET_REG8(CYREG_CMP0_SW6);
              
                      cyPmBackup.cmpData[5u]  = CY_GET_REG8(CYREG_CMP1_SW0);
                      cyPmBackup.cmpData[6u]  = CY_GET_REG8(CYREG_CMP1_SW2);
                      cyPmBackup.cmpData[7u]  = CY_GET_REG8(CYREG_CMP1_SW3);
                      cyPmBackup.cmpData[8u]  = CY_GET_REG8(CYREG_CMP1_SW4);
                      cyPmBackup.cmpData[9u]  = CY_GET_REG8(CYREG_CMP1_SW6);
              
                      cyPmBackup.cmpData[10u] = CY_GET_REG8(CYREG_CMP2_SW0);
                      cyPmBackup.cmpData[11u] = CY_GET_REG8(CYREG_CMP2_SW2);
                      cyPmBackup.cmpData[12u] = CY_GET_REG8(CYREG_CMP2_SW3);
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 33  

                      cyPmBackup.cmpData[13u] = CY_GET_REG8(CYREG_CMP2_SW4);
                      cyPmBackup.cmpData[14u] = CY_GET_REG8(CYREG_CMP2_SW6);
              
                      cyPmBackup.cmpData[15u] = CY_GET_REG8(CYREG_CMP3_SW0);
                      cyPmBackup.cmpData[16u] = CY_GET_REG8(CYREG_CMP3_SW2);
                      cyPmBackup.cmpData[17u] = CY_GET_REG8(CYREG_CMP3_SW3);
                      cyPmBackup.cmpData[18u] = CY_GET_REG8(CYREG_CMP3_SW4);
                      cyPmBackup.cmpData[19u] = CY_GET_REG8(CYREG_CMP3_SW6);
              
              
                      /* Clear CMP routing registers */
                      CY_SET_REG8(CYREG_CMP0_SW0 , 0u);
                      CY_SET_REG8(CYREG_CMP0_SW2 , 0u);
                      CY_SET_REG8(CYREG_CMP0_SW3 , 0u);
                      CY_SET_REG8(CYREG_CMP0_SW4 , 0u);
                      CY_SET_REG8(CYREG_CMP0_SW6 , 0u);
              
                      CY_SET_REG8(CYREG_CMP1_SW0 , 0u);
                      CY_SET_REG8(CYREG_CMP1_SW2 , 0u);
                      CY_SET_REG8(CYREG_CMP1_SW3 , 0u);
                      CY_SET_REG8(CYREG_CMP1_SW4 , 0u);
                      CY_SET_REG8(CYREG_CMP1_SW6 , 0u);
              
                      CY_SET_REG8(CYREG_CMP2_SW0 , 0u);
                      CY_SET_REG8(CYREG_CMP2_SW2 , 0u);
                      CY_SET_REG8(CYREG_CMP2_SW3 , 0u);
                      CY_SET_REG8(CYREG_CMP2_SW4 , 0u);
                      CY_SET_REG8(CYREG_CMP2_SW6 , 0u);
              
                      CY_SET_REG8(CYREG_CMP3_SW0 , 0u);
                      CY_SET_REG8(CYREG_CMP3_SW2 , 0u);
                      CY_SET_REG8(CYREG_CMP3_SW3 , 0u);
                      CY_SET_REG8(CYREG_CMP3_SW4 , 0u);
                      CY_SET_REG8(CYREG_CMP3_SW6 , 0u);
              
              
                      /* Save DAC routing registers */
                      cyPmBackup.dacData[0u]  = CY_GET_REG8(CYREG_DAC0_SW0);
                      cyPmBackup.dacData[1u]  = CY_GET_REG8(CYREG_DAC0_SW2);
                      cyPmBackup.dacData[2u]  = CY_GET_REG8(CYREG_DAC0_SW3);
                      cyPmBackup.dacData[3u]  = CY_GET_REG8(CYREG_DAC0_SW4);
              
                      cyPmBackup.dacData[4u]  = CY_GET_REG8(CYREG_DAC1_SW0);
                      cyPmBackup.dacData[5u]  = CY_GET_REG8(CYREG_DAC1_SW2);
                      cyPmBackup.dacData[6u]  = CY_GET_REG8(CYREG_DAC1_SW3);
                      cyPmBackup.dacData[7u]  = CY_GET_REG8(CYREG_DAC1_SW4);
              
                      cyPmBackup.dacData[8u]  = CY_GET_REG8(CYREG_DAC2_SW0);
                      cyPmBackup.dacData[9u]  = CY_GET_REG8(CYREG_DAC2_SW2);
                      cyPmBackup.dacData[10u] = CY_GET_REG8(CYREG_DAC2_SW3);
                      cyPmBackup.dacData[11u] = CY_GET_REG8(CYREG_DAC2_SW4);
              
                      cyPmBackup.dacData[12u] = CY_GET_REG8(CYREG_DAC3_SW0);
                      cyPmBackup.dacData[13u] = CY_GET_REG8(CYREG_DAC3_SW2);
                      cyPmBackup.dacData[14u] = CY_GET_REG8(CYREG_DAC3_SW3);
                      cyPmBackup.dacData[15u] = CY_GET_REG8(CYREG_DAC3_SW4);
              
                      /* Clear DAC routing registers */
                      CY_SET_REG8(CYREG_DAC0_SW0 , 0u);
                      CY_SET_REG8(CYREG_DAC0_SW2 , 0u);
                      CY_SET_REG8(CYREG_DAC0_SW3 , 0u);
                      CY_SET_REG8(CYREG_DAC0_SW4 , 0u);
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 34  

              
                      CY_SET_REG8(CYREG_DAC1_SW0 , 0u);
                      CY_SET_REG8(CYREG_DAC1_SW2 , 0u);
                      CY_SET_REG8(CYREG_DAC1_SW3 , 0u);
                      CY_SET_REG8(CYREG_DAC1_SW4 , 0u);
              
                      CY_SET_REG8(CYREG_DAC2_SW0 , 0u);
                      CY_SET_REG8(CYREG_DAC2_SW2 , 0u);
                      CY_SET_REG8(CYREG_DAC2_SW3 , 0u);
                      CY_SET_REG8(CYREG_DAC2_SW4 , 0u);
              
                      CY_SET_REG8(CYREG_DAC3_SW0 , 0u);
                      CY_SET_REG8(CYREG_DAC3_SW2 , 0u);
                      CY_SET_REG8(CYREG_DAC3_SW3 , 0u);
                      CY_SET_REG8(CYREG_DAC3_SW4 , 0u);
              
              
                      /* Save DSM routing registers */
                      cyPmBackup.dsmData[0u]  = CY_GET_REG8(CYREG_DSM0_SW0);
                      cyPmBackup.dsmData[1u]  = CY_GET_REG8(CYREG_DSM0_SW2);
                      cyPmBackup.dsmData[2u]  = CY_GET_REG8(CYREG_DSM0_SW3);
                      cyPmBackup.dsmData[3u]  = CY_GET_REG8(CYREG_DSM0_SW4);
                      cyPmBackup.dsmData[4u]  = CY_GET_REG8(CYREG_DSM0_SW6);
              
                      /* Clear DSM routing registers */
                      CY_SET_REG8(CYREG_DSM0_SW0 , 0u);
                      CY_SET_REG8(CYREG_DSM0_SW2 , 0u);
                      CY_SET_REG8(CYREG_DSM0_SW3 , 0u);
                      CY_SET_REG8(CYREG_DSM0_SW4 , 0u);
                      CY_SET_REG8(CYREG_DSM0_SW6 , 0u);
              
              
                      /* Save SAR routing registers */
                      cyPmBackup.sarData[0u]  = CY_GET_REG8(CYREG_SAR0_SW0);
                      cyPmBackup.sarData[1u]  = CY_GET_REG8(CYREG_SAR0_SW2);
                      cyPmBackup.sarData[2u]  = CY_GET_REG8(CYREG_SAR0_SW3);
                      cyPmBackup.sarData[3u]  = CY_GET_REG8(CYREG_SAR0_SW4);
                      cyPmBackup.sarData[4u]  = CY_GET_REG8(CYREG_SAR0_SW6);
              
                      cyPmBackup.sarData[5u]  = CY_GET_REG8(CYREG_SAR1_SW0);
                      cyPmBackup.sarData[6u]  = CY_GET_REG8(CYREG_SAR1_SW2);
                      cyPmBackup.sarData[7u]  = CY_GET_REG8(CYREG_SAR1_SW3);
                      cyPmBackup.sarData[8u]  = CY_GET_REG8(CYREG_SAR1_SW4);
                      cyPmBackup.sarData[9u]  = CY_GET_REG8(CYREG_SAR1_SW6);
              
              
                      /* Clear SAR routing registers */
                      CY_SET_REG8(CYREG_SAR0_SW0 , 0u);
                      CY_SET_REG8(CYREG_SAR0_SW2 , 0u);
                      CY_SET_REG8(CYREG_SAR0_SW3 , 0u);
                      CY_SET_REG8(CYREG_SAR0_SW4 , 0u);
                      CY_SET_REG8(CYREG_SAR0_SW6 , 0u);
              
                      CY_SET_REG8(CYREG_SAR1_SW0 , 0u);
                      CY_SET_REG8(CYREG_SAR1_SW2 , 0u);
                      CY_SET_REG8(CYREG_SAR1_SW3 , 0u);
                      CY_SET_REG8(CYREG_SAR1_SW4 , 0u);
                      CY_SET_REG8(CYREG_SAR1_SW6 , 0u);
              
                  #endif  /* (CY_PSOC5A) */
2091   1      
2092   1      
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 35  

2093   1          #if(CY_PSOC3 || CY_PSOC5A || CY_PSOC5LP)
2094   1      
2095   1              /* Save SC/CT routing registers */
2096   1              cyPmBackup.scctData[0u]   = CY_GET_REG8(CYREG_SC0_SW0 );
2097   1              cyPmBackup.scctData[1u]   = CY_GET_REG8(CYREG_SC0_SW2 );
2098   1              cyPmBackup.scctData[2u]   = CY_GET_REG8(CYREG_SC0_SW3 );
2099   1              cyPmBackup.scctData[3u]   = CY_GET_REG8(CYREG_SC0_SW4 );
2100   1              cyPmBackup.scctData[4u]   = CY_GET_REG8(CYREG_SC0_SW6 );
2101   1              cyPmBackup.scctData[5u]   = CY_GET_REG8(CYREG_SC0_SW8 );
2102   1              cyPmBackup.scctData[6u]   = CY_GET_REG8(CYREG_SC0_SW10);
2103   1      
2104   1              cyPmBackup.scctData[7u]   = CY_GET_REG8(CYREG_SC1_SW0 );
2105   1              cyPmBackup.scctData[8u]   = CY_GET_REG8(CYREG_SC1_SW2 );
2106   1              cyPmBackup.scctData[9u]   = CY_GET_REG8(CYREG_SC1_SW3 );
2107   1              cyPmBackup.scctData[10u]  = CY_GET_REG8(CYREG_SC1_SW4 );
2108   1              cyPmBackup.scctData[11u]  = CY_GET_REG8(CYREG_SC1_SW6 );
2109   1              cyPmBackup.scctData[12u]  = CY_GET_REG8(CYREG_SC1_SW8 );
2110   1              cyPmBackup.scctData[13u]  = CY_GET_REG8(CYREG_SC1_SW10);
2111   1      
2112   1              cyPmBackup.scctData[14u]  = CY_GET_REG8(CYREG_SC2_SW0 );
2113   1              cyPmBackup.scctData[15u]  = CY_GET_REG8(CYREG_SC2_SW2 );
2114   1              cyPmBackup.scctData[16u]  = CY_GET_REG8(CYREG_SC2_SW3 );
2115   1              cyPmBackup.scctData[17u]  = CY_GET_REG8(CYREG_SC2_SW4 );
2116   1              cyPmBackup.scctData[18u]  = CY_GET_REG8(CYREG_SC2_SW6 );
2117   1              cyPmBackup.scctData[19u]  = CY_GET_REG8(CYREG_SC2_SW8 );
2118   1              cyPmBackup.scctData[20u]  = CY_GET_REG8(CYREG_SC2_SW10);
2119   1      
2120   1              cyPmBackup.scctData[21u]  = CY_GET_REG8(CYREG_SC3_SW0 );
2121   1              cyPmBackup.scctData[22u]  = CY_GET_REG8(CYREG_SC3_SW2 );
2122   1              cyPmBackup.scctData[23u]  = CY_GET_REG8(CYREG_SC3_SW3 );
2123   1              cyPmBackup.scctData[24u]  = CY_GET_REG8(CYREG_SC3_SW4 );
2124   1              cyPmBackup.scctData[25u]  = CY_GET_REG8(CYREG_SC3_SW6 );
2125   1              cyPmBackup.scctData[26u]  = CY_GET_REG8(CYREG_SC3_SW8 );
2126   1              cyPmBackup.scctData[27u]  = CY_GET_REG8(CYREG_SC3_SW10);
2127   1      
2128   1              CY_SET_REG8(CYREG_SC0_SW0 , 0u);
2129   1              CY_SET_REG8(CYREG_SC0_SW2 , 0u);
2130   1              CY_SET_REG8(CYREG_SC0_SW3 , 0u);
2131   1              CY_SET_REG8(CYREG_SC0_SW4 , 0u);
2132   1              CY_SET_REG8(CYREG_SC0_SW6 , 0u);
2133   1              CY_SET_REG8(CYREG_SC0_SW8 , 0u);
2134   1              CY_SET_REG8(CYREG_SC0_SW10, 0u);
2135   1      
2136   1              CY_SET_REG8(CYREG_SC1_SW0 , 0u);
2137   1              CY_SET_REG8(CYREG_SC1_SW2 , 0u);
2138   1              CY_SET_REG8(CYREG_SC1_SW3 , 0u);
2139   1              CY_SET_REG8(CYREG_SC1_SW4 , 0u);
2140   1              CY_SET_REG8(CYREG_SC1_SW6 , 0u);
2141   1              CY_SET_REG8(CYREG_SC1_SW8 , 0u);
2142   1              CY_SET_REG8(CYREG_SC1_SW10, 0u);
2143   1      
2144   1              CY_SET_REG8(CYREG_SC2_SW0 , 0u);
2145   1              CY_SET_REG8(CYREG_SC2_SW2 , 0u);
2146   1              CY_SET_REG8(CYREG_SC2_SW3 , 0u);
2147   1              CY_SET_REG8(CYREG_SC2_SW4 , 0u);
2148   1              CY_SET_REG8(CYREG_SC2_SW6 , 0u);
2149   1              CY_SET_REG8(CYREG_SC2_SW8 , 0u);
2150   1              CY_SET_REG8(CYREG_SC2_SW10, 0u);
2151   1      
2152   1              CY_SET_REG8(CYREG_SC3_SW0 , 0u);
2153   1              CY_SET_REG8(CYREG_SC3_SW2 , 0u);
2154   1              CY_SET_REG8(CYREG_SC3_SW3 , 0u);
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 36  

2155   1              CY_SET_REG8(CYREG_SC3_SW4 , 0u);
2156   1              CY_SET_REG8(CYREG_SC3_SW6 , 0u);
2157   1              CY_SET_REG8(CYREG_SC3_SW8 , 0u);
2158   1              CY_SET_REG8(CYREG_SC3_SW10, 0u);
2159   1      
2160   1          #endif  /* (CY_PSOC3 || CY_PSOC5A || CY_PSOC5LP) */
2161   1      
2162   1      
2163   1          #if(CY_PSOC3)
2164   1      
2165   1              /* Serial Wire Viewer (SWV) workaround */
2166   1      
2167   1              /* Disable SWV before entering low power mode */
2168   1              if(0u != (CY_PM_MLOGIC_DBG_REG & CY_PM_MLOGIC_DBG_SWV_CLK_EN))
2169   1              {
2170   2                  /* Save SWV clock enabled state */
2171   2                  cyPmBackup.swvClkEnabled = CY_PM_ENABLED;
2172   2      
2173   2                  /* Save current ports drive mode settings */
2174   2                  cyPmBackup.prt1Dm = CY_PM_PRT1_PC3_REG & ((uint8)(~CY_PM_PRT1_PC3_DM_MASK));
2175   2      
2176   2                  /* Set drive mode to strong output */
2177   2                  CY_PM_PRT1_PC3_REG = (CY_PM_PRT1_PC3_REG & CY_PM_PRT1_PC3_DM_MASK) |
2178   2                                      CY_PM_PRT1_PC3_DM_STRONG;
2179   2      
2180   2                  /* Disable SWV clocks */
2181   2                  CY_PM_MLOGIC_DBG_REG &= ((uint8)(~CY_PM_MLOGIC_DBG_SWV_CLK_EN));
2182   2              }
2183   1              else
2184   1              {
2185   2                  /* Save SWV clock disabled state */
2186   2                  cyPmBackup.swvClkEnabled = CY_PM_DISABLED;
2187   2              }
2188   1      
2189   1          #endif  /* (CY_PSOC3) */
2190   1      
2191   1      
2192   1          /***************************************************************************
2193   1          * Save boost reference and set it to boost's internal by clearing the bit.
2194   1          * External (chip bandgap) reference is not available in Sleep and Hibernate.
2195   1          ***************************************************************************/
2196   1          if(0u != (CY_PM_BOOST_CR2_REG & CY_PM_BOOST_CR2_EREFSEL_EXT))
2197   1          {
2198   2              cyPmBackup.boostRefExt = CY_PM_ENABLED;
2199   2              CY_PM_BOOST_CR2_REG &= ((uint8)(~CY_PM_BOOST_CR2_EREFSEL_EXT));
2200   2          }
2201   1          else
2202   1          {
2203   2              cyPmBackup.boostRefExt = CY_PM_DISABLED;
2204   2          }
2205   1      }
2206          
2207          
2208          /*******************************************************************************
2209          * Function Name: CyPmHibSlpRestore
2210          ********************************************************************************
2211          *
2212          * Summary:
2213          *  This API is used for restoring device configurations after wakeup from Sleep
2214          *  and Hibernate low power modes:
2215          *  - Restores COMP, VIDAC, DSM and SAR routing connections (PSoC 5)
2216          *  - Restores SC/CT routing connections (PSoC 3/5/5LP)
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 37  

2217          *  - Restores enable state of Serial Wire Viewer (SWV) (PSoC 3)
2218          *  - Restores initial buzz rate (PSoC 5)
2219          *  - Restore boost reference selection
2220          *
2221          * Parameters:
2222          *  None
2223          *
2224          * Return:
2225          *  None
2226          *
2227          *******************************************************************************/
2228          static void CyPmHibSlpRestore(void) 
2229          {
2230   1          #if(CY_PSOC5A)
              
                      /* Restore COMP routing registers */
                      CY_SET_REG8(CYREG_CMP0_SW0 , cyPmBackup.cmpData[0u] );
                      CY_SET_REG8(CYREG_CMP0_SW2 , cyPmBackup.cmpData[1u] );
                      CY_SET_REG8(CYREG_CMP0_SW3 , cyPmBackup.cmpData[2u] );
                      CY_SET_REG8(CYREG_CMP0_SW4 , cyPmBackup.cmpData[3u] );
                      CY_SET_REG8(CYREG_CMP0_SW6 , cyPmBackup.cmpData[4u] );
              
                      CY_SET_REG8(CYREG_CMP1_SW0 , cyPmBackup.cmpData[5u] );
                      CY_SET_REG8(CYREG_CMP1_SW2 , cyPmBackup.cmpData[6u] );
                      CY_SET_REG8(CYREG_CMP1_SW3 , cyPmBackup.cmpData[7u] );
                      CY_SET_REG8(CYREG_CMP1_SW4 , cyPmBackup.cmpData[8u] );
                      CY_SET_REG8(CYREG_CMP1_SW6 , cyPmBackup.cmpData[9u] );
              
                      CY_SET_REG8(CYREG_CMP2_SW0 , cyPmBackup.cmpData[10u]);
                      CY_SET_REG8(CYREG_CMP2_SW2 , cyPmBackup.cmpData[11u]);
                      CY_SET_REG8(CYREG_CMP2_SW3 , cyPmBackup.cmpData[12u]);
                      CY_SET_REG8(CYREG_CMP2_SW4 , cyPmBackup.cmpData[13u]);
                      CY_SET_REG8(CYREG_CMP2_SW6 , cyPmBackup.cmpData[14u]);
              
                      CY_SET_REG8(CYREG_CMP3_SW0 , cyPmBackup.cmpData[15u]);
                      CY_SET_REG8(CYREG_CMP3_SW2 , cyPmBackup.cmpData[16u]);
                      CY_SET_REG8(CYREG_CMP3_SW3 , cyPmBackup.cmpData[17u]);
                      CY_SET_REG8(CYREG_CMP3_SW4 , cyPmBackup.cmpData[18u]);
                      CY_SET_REG8(CYREG_CMP3_SW6 , cyPmBackup.cmpData[19u]);
              
                      /* Restore DAC routing registers */
                      CY_SET_REG8(CYREG_DAC0_SW0 , cyPmBackup.dacData[0u] );
                      CY_SET_REG8(CYREG_DAC0_SW2 , cyPmBackup.dacData[1u] );
                      CY_SET_REG8(CYREG_DAC0_SW3 , cyPmBackup.dacData[2u] );
                      CY_SET_REG8(CYREG_DAC0_SW4 , cyPmBackup.dacData[3u] );
              
                      CY_SET_REG8(CYREG_DAC1_SW0 , cyPmBackup.dacData[4u] );
                      CY_SET_REG8(CYREG_DAC1_SW2 , cyPmBackup.dacData[5u] );
                      CY_SET_REG8(CYREG_DAC1_SW3 , cyPmBackup.dacData[6u] );
                      CY_SET_REG8(CYREG_DAC1_SW4 , cyPmBackup.dacData[7u] );
              
                      CY_SET_REG8(CYREG_DAC2_SW0 , cyPmBackup.dacData[8u] );
                      CY_SET_REG8(CYREG_DAC2_SW2 , cyPmBackup.dacData[9u] );
                      CY_SET_REG8(CYREG_DAC2_SW3 , cyPmBackup.dacData[10u]);
                      CY_SET_REG8(CYREG_DAC2_SW4 , cyPmBackup.dacData[11u]);
              
                      CY_SET_REG8(CYREG_DAC3_SW0 , cyPmBackup.dacData[12u]);
                      CY_SET_REG8(CYREG_DAC3_SW2 , cyPmBackup.dacData[13u]);
                      CY_SET_REG8(CYREG_DAC3_SW3 , cyPmBackup.dacData[14u]);
                      CY_SET_REG8(CYREG_DAC3_SW4 , cyPmBackup.dacData[15u]);
              
              
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 38  

                      /* Restore DSM routing registers */
                      CY_SET_REG8(CYREG_DSM0_SW0 , cyPmBackup.dsmData[0u]);
                      CY_SET_REG8(CYREG_DSM0_SW2 , cyPmBackup.dsmData[1u]);
                      CY_SET_REG8(CYREG_DSM0_SW3 , cyPmBackup.dsmData[2u]);
                      CY_SET_REG8(CYREG_DSM0_SW4 , cyPmBackup.dsmData[3u]);
                      CY_SET_REG8(CYREG_DSM0_SW6 , cyPmBackup.dsmData[4u]);
              
              
                      /* Restore SAR routing registers */
                      CY_SET_REG8(CYREG_SAR0_SW0 , cyPmBackup.sarData[0u]);
                      CY_SET_REG8(CYREG_SAR0_SW2 , cyPmBackup.sarData[1u]);
                      CY_SET_REG8(CYREG_SAR0_SW3 , cyPmBackup.sarData[2u]);
                      CY_SET_REG8(CYREG_SAR0_SW4 , cyPmBackup.sarData[3u]);
                      CY_SET_REG8(CYREG_SAR0_SW6 , cyPmBackup.sarData[4u]);
              
                      CY_SET_REG8(CYREG_SAR1_SW0 , cyPmBackup.sarData[5u]);
                      CY_SET_REG8(CYREG_SAR1_SW2 , cyPmBackup.sarData[6u]);
                      CY_SET_REG8(CYREG_SAR1_SW3 , cyPmBackup.sarData[7u]);
                      CY_SET_REG8(CYREG_SAR1_SW4 , cyPmBackup.sarData[8u]);
                      CY_SET_REG8(CYREG_SAR1_SW6 , cyPmBackup.sarData[9u]);
              
                  #endif  /* (CY_PSOC5A) */
2301   1      
2302   1          #if(CY_PSOC3 || CY_PSOC5A || CY_PSOC5LP)
2303   1      
2304   1              /* Restore SC/CT routing registers */
2305   1              CY_SET_REG8(CYREG_SC0_SW0 , cyPmBackup.scctData[0u] );
2306   1              CY_SET_REG8(CYREG_SC0_SW2 , cyPmBackup.scctData[1u] );
2307   1              CY_SET_REG8(CYREG_SC0_SW3 , cyPmBackup.scctData[2u] );
2308   1              CY_SET_REG8(CYREG_SC0_SW4 , cyPmBackup.scctData[3u] );
2309   1              CY_SET_REG8(CYREG_SC0_SW6 , cyPmBackup.scctData[4u] );
2310   1              CY_SET_REG8(CYREG_SC0_SW8 , cyPmBackup.scctData[5u] );
2311   1              CY_SET_REG8(CYREG_SC0_SW10, cyPmBackup.scctData[6u] );
2312   1      
2313   1              CY_SET_REG8(CYREG_SC1_SW0 , cyPmBackup.scctData[7u] );
2314   1              CY_SET_REG8(CYREG_SC1_SW2 , cyPmBackup.scctData[8u] );
2315   1              CY_SET_REG8(CYREG_SC1_SW3 , cyPmBackup.scctData[9u] );
2316   1              CY_SET_REG8(CYREG_SC1_SW4 , cyPmBackup.scctData[10u]);
2317   1              CY_SET_REG8(CYREG_SC1_SW6 , cyPmBackup.scctData[11u]);
2318   1              CY_SET_REG8(CYREG_SC1_SW8 , cyPmBackup.scctData[12u]);
2319   1              CY_SET_REG8(CYREG_SC1_SW10, cyPmBackup.scctData[13u]);
2320   1      
2321   1              CY_SET_REG8(CYREG_SC2_SW0 , cyPmBackup.scctData[14u]);
2322   1              CY_SET_REG8(CYREG_SC2_SW2 , cyPmBackup.scctData[15u]);
2323   1              CY_SET_REG8(CYREG_SC2_SW3 , cyPmBackup.scctData[16u]);
2324   1              CY_SET_REG8(CYREG_SC2_SW4 , cyPmBackup.scctData[17u]);
2325   1              CY_SET_REG8(CYREG_SC2_SW6 , cyPmBackup.scctData[18u]);
2326   1              CY_SET_REG8(CYREG_SC2_SW8 , cyPmBackup.scctData[19u]);
2327   1              CY_SET_REG8(CYREG_SC2_SW10, cyPmBackup.scctData[20u]);
2328   1      
2329   1              CY_SET_REG8(CYREG_SC3_SW0 , cyPmBackup.scctData[21u]);
2330   1              CY_SET_REG8(CYREG_SC3_SW2 , cyPmBackup.scctData[22u]);
2331   1              CY_SET_REG8(CYREG_SC3_SW3 , cyPmBackup.scctData[23u]);
2332   1              CY_SET_REG8(CYREG_SC3_SW4 , cyPmBackup.scctData[24u]);
2333   1              CY_SET_REG8(CYREG_SC3_SW6 , cyPmBackup.scctData[25u]);
2334   1              CY_SET_REG8(CYREG_SC3_SW8 , cyPmBackup.scctData[26u]);
2335   1              CY_SET_REG8(CYREG_SC3_SW10, cyPmBackup.scctData[27u]);
2336   1      
2337   1          #endif  /* (CY_PSOC3 || CY_PSOC5A || CY_PSOC5LP) */
2338   1      
2339   1      
2340   1          #if(CY_PSOC3)
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 39  

2341   1      
2342   1              /* Serial Wire Viewer (SWV) workaround */
2343   1              if(CY_PM_ENABLED == cyPmBackup.swvClkEnabled)
2344   1              {
2345   2                  /* Restore ports drive mode */
2346   2                  CY_PM_PRT1_PC3_REG = (CY_PM_PRT1_PC3_REG & CY_PM_PRT1_PC3_DM_MASK) |
2347   2                                          cyPmBackup.prt1Dm;
2348   2      
2349   2                  /* Enable SWV clocks */
2350   2                  CY_PM_MLOGIC_DBG_REG |= CY_PM_MLOGIC_DBG_SWV_CLK_EN;
2351   2              }
2352   1      
2353   1          #endif /* (CY_PSOC3) */
2354   1      
2355   1      
2356   1          #if(CY_PSOC5A)
              
                      /* Restore buzz sleep trim value */
                      CY_PM_PWRSYS_BUZZ_TR_REG = cyPmBackup.buzzSleepTrim | \
                                                (CY_PM_PWRSYS_BUZZ_TR_REG & CY_PM_PWRSYS_BUZZ_TR_MASK);
              
                  #endif  /* (CY_PSOC5A) */
2363   1      
2364   1      
2365   1          /* Restore boost reference */
2366   1          if(CY_PM_ENABLED == cyPmBackup.boostRefExt)
2367   1          {
2368   2              CY_PM_BOOST_CR2_REG |= CY_PM_BOOST_CR2_EREFSEL_EXT;
2369   2          }
2370   1      }
2371          
2372          
2373          /*******************************************************************************
2374          * Function Name: CyPmHviLviSaveDisable
2375          ********************************************************************************
2376          *
2377          * Summary:
2378          *  Saves analog and digital LVI and HVI configuration and disables them.
2379          *
2380          * Parameters:
2381          *  None
2382          *
2383          * Return:
2384          *  None
2385          *
2386          * Reentrant:
2387          *  No
2388          *
2389          *******************************************************************************/
2390          static void CyPmHviLviSaveDisable(void) 
2391          {
2392   1          if(0u != (CY_VD_LVI_HVI_CONTROL_REG & CY_VD_LVID_EN))
2393   1          {
2394   2              cyPmBackup.lvidEn = CY_PM_ENABLED;
2395   2              cyPmBackup.lvidTrip = CY_VD_LVI_TRIP_REG & CY_VD_LVI_TRIP_LVID_MASK;
2396   2      
2397   2              /* Save state of reset device at a specified Vddd threshold */
2398   2              #if(CY_PSOC5A)
              
                          /* Not applicable PSoC 5 */
                          cyPmBackup.lvidRst = CY_PM_DISABLED;
              
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 40  

                      #else
2404   2      
2405   2                  cyPmBackup.lvidRst = (0u == (CY_VD_PRES_CONTROL_REG & CY_VD_PRESD_EN)) ? \
2406   2                                          CY_PM_DISABLED : CY_PM_ENABLED;
2407   2      
2408   2              #endif  /* (CY_PSOC5A) */
2409   2      
2410   2              CyVdLvDigitDisable();
2411   2          }
2412   1          else
2413   1          {
2414   2              cyPmBackup.lvidEn = CY_PM_DISABLED;
2415   2          }
2416   1      
2417   1          if(0u != (CY_VD_LVI_HVI_CONTROL_REG & CY_VD_LVIA_EN))
2418   1          {
2419   2              cyPmBackup.lviaEn = CY_PM_ENABLED;
2420   2              cyPmBackup.lviaTrip = CY_VD_LVI_TRIP_REG >> 4u;
2421   2      
2422   2              /* Save state of reset device at a specified Vdda threshold */
2423   2              #if(CY_PSOC5A)
              
                          /* Not applicable PSoC 5 */
                          cyPmBackup.lviaRst = CY_PM_DISABLED;
              
                      #else
2429   2      
2430   2                  cyPmBackup.lviaRst = (0u == (CY_VD_PRES_CONTROL_REG & CY_VD_PRESA_EN)) ? \
2431   2                                          CY_PM_DISABLED : CY_PM_ENABLED;
2432   2      
2433   2              #endif  /* (CY_PSOC5A) */
2434   2      
2435   2              CyVdLvAnalogDisable();
2436   2          }
2437   1          else
2438   1          {
2439   2              cyPmBackup.lviaEn = CY_PM_DISABLED;
2440   2          }
2441   1      
2442   1          if(0u != (CY_VD_LVI_HVI_CONTROL_REG & CY_VD_HVIA_EN))
2443   1          {
2444   2              cyPmBackup.hviaEn = CY_PM_ENABLED;
2445   2              CyVdHvAnalogDisable();
2446   2          }
2447   1          else
2448   1          {
2449   2              cyPmBackup.hviaEn = CY_PM_DISABLED;
2450   2          }
2451   1      }
2452          
2453          
2454          /*******************************************************************************
2455          * Function Name: CyPmHviLviRestore
2456          ********************************************************************************
2457          *
2458          * Summary:
2459          *  Restores analog and digital LVI and HVI configuration.
2460          *
2461          * Parameters:
2462          *  None
2463          *
2464          * Return:
C51 COMPILER V9.03   CYPM                                                                  03/09/2016 17:02:53 PAGE 41  

2465          *  None
2466          *
2467          * Reentrant:
2468          *  No
2469          *
2470          *******************************************************************************/
2471          static void CyPmHviLviRestore(void) 
2472          {
2473   1          /* Restore LVI/HVI configuration */
2474   1          if(CY_PM_ENABLED == cyPmBackup.lvidEn)
2475   1          {
2476   2              CyVdLvDigitEnable(cyPmBackup.lvidRst, cyPmBackup.lvidTrip);
2477   2          }
2478   1      
2479   1          if(CY_PM_ENABLED == cyPmBackup.lviaEn)
2480   1          {
2481   2              CyVdLvAnalogEnable(cyPmBackup.lviaRst, cyPmBackup.lviaTrip);
2482   2          }
2483   1      
2484   1          if(CY_PM_ENABLED == cyPmBackup.hviaEn)
2485   1          {
2486   2              CyVdHvAnalogEnable();
2487   2          }
2488   1      }
2489          
2490          
2491          /* [] END OF FILE */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2995    ----
   CONSTANT SIZE    =     14    ----
   XDATA SIZE       =     65      14
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
