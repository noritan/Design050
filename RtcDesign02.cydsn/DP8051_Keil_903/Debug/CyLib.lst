C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 1   


C51 COMPILER V9.03, COMPILATION OF MODULE CYLIB
OBJECT MODULE PLACED IN .\DP8051_Keil_903\Debug\CyLib.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\2.2\PSoC Creator\import\keil\pk51\9.03\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\CyLib.c NOIV LARGE MODDP2 OMF2 VB(1) PR(.\DP8051_Keil_903\Debug\CyLib.lst) DB NOIP OT(5,SIZE) I
                    -NCDIR(Generated_Source\PSoC3) OJ(.\DP8051_Keil_903\Debug\CyLib.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: CyLib.c
   3          * Version 3.30
   4          *
   5          *  Description:
   6          *   Provides system API for the clocking, interrupts and watchdog timer.
   7          *
   8          *  Note:
   9          *   Documentation of the API's in this file is located in the
  10          *   System Reference Guide provided with PSoC Creator.
  11          *
  12          ********************************************************************************
  13          * Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
  14          * You may use this file only in accordance with the license, terms, conditions,
  15          * disclaimers, and limitations in the end user license agreement accompanying
  16          * the software package with which this file was provided.
  17          *******************************************************************************/
  18          
  19          #include "CyLib.h"
  20          
  21          
  22          /*******************************************************************************
  23          * The CyResetStatus variable is used to obtain value of RESET_SR0 register after
  24          * a device reset.
  25          *******************************************************************************/
  26          uint8 CYXDATA CyResetStatus;
  27          
  28          
  29          #if(!CY_PSOC5A)
  30          
  31              /* Variable Vdda */
  32              #if(CYDEV_VARIABLE_VDDA == 1)
              
                      uint8 CyScPumpEnabled = (uint8)(CYDEV_VDDA_MV < 2700);
              
                  #endif  /* (CYDEV_VARIABLE_VDDA == 1) */
  37          
  38          #endif /* (!CY_PSOC5A) */
  39          
  40          
  41          /* Do not use these definitions directly in your application */
  42          uint32 cydelay_freq_hz  = BCLK__BUS_CLK__HZ;
  43          uint32 cydelay_freq_khz = (BCLK__BUS_CLK__HZ + 999u) / 1000u;
  44          uint8  cydelay_freq_mhz = (uint8)((BCLK__BUS_CLK__HZ + 999999u) / 1000000u);
  45          uint32 cydelay_32k_ms   = 32768u * ((BCLK__BUS_CLK__HZ + 999u) / 1000u);
  46          
  47          
  48          /* Function Prototypes */
  49          static uint8 CyUSB_PowerOnCheck(void)  ;
  50          static void CyIMO_SetTrimValue(uint8 freq) ;
  51          static void CyBusClk_Internal_SetDivider(uint16 divider);
  52          
  53          
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 2   

  54          /*******************************************************************************
  55          * Function Name: CyPLL_OUT_Start
  56          ********************************************************************************
  57          *
  58          * Summary:
  59          *   Enables the PLL.  Optionally waits for it to become stable.
  60          *   Waits at least 250 us or until it is detected that the PLL is stable.
  61          *
  62          * Parameters:
  63          *   wait:
  64          *    0: Return immediately after configuration
  65          *    1: Wait for PLL lock or timeout.
  66          *
  67          * Return:
  68          *   Status
  69          *    CYRET_SUCCESS - Completed successfully
  70          *    CYRET_TIMEOUT - Timeout occurred without detecting a stable clock.
  71          *     If the input source of the clock is jittery, then the lock indication
  72          *     may not occur.  However, after the timeout has expired the generated PLL
  73          *     clock can still be used.
  74          *
  75          * Side Effects:
  76          *  If wait is enabled: This function wses the Fast Time Wheel to time the wait.
  77          *  Any other use of the Fast Time Wheel will be stopped during the period of
  78          *  this function and then restored. This function also uses the 100 KHz ILO.
  79          *  If not enabled, this function will enable the 100 KHz ILO for the period of
  80          *  this function.
  81          *
  82          *  No changes to the setup of the ILO, Fast Time Wheel, Central Time Wheel or
  83          *  Once Per Second interrupt may be made by interrupt routines during the period
  84          *  of this function execution. The current operation of the ILO, Central Time
  85          *  Wheel and Once Per Second interrupt are maintained during the operation of
  86          *  this function provided the reading of the Power Manager Interrupt Status
  87          *  Register is only done using the CyPmReadStatus() function.
  88          *
  89          *******************************************************************************/
  90          cystatus CyPLL_OUT_Start(uint8 wait) 
  91          {
  92   1          cystatus status = CYRET_SUCCESS;
  93   1      
  94   1          uint8 iloEnableState;
  95   1          uint8 pmTwCfg0State;
  96   1          uint8 pmTwCfg2State;
  97   1      
  98   1      
  99   1          /* Enables the PLL circuit  */
 100   1          CY_CLK_PLL_CFG0_REG |= CY_CLK_PLL_ENABLE;
 101   1      
 102   1          if(wait != 0u)
 103   1          {
 104   2              /* Save 100 KHz ILO, FTW interval, enable and interrupt enable */
 105   2              iloEnableState = SLOWCLK_ILO_CR0;
 106   2              pmTwCfg0State = CY_PM_TW_CFG0_REG;
 107   2              pmTwCfg2State = CY_PM_TW_CFG2_REG;
 108   2      
 109   2              CyPmFtwSetInterval(CY_CLK_PLL_FTW_INTERVAL);
 110   2      
 111   2              status = CYRET_TIMEOUT;
 112   2      
 113   2      
 114   2              while(CyPmReadStatus(CY_PM_FTW_INT) != CY_PM_FTW_INT)
 115   2              {
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 3   

 116   3                  /* Wait for the interrupt status */
 117   3                  if(0u != (CY_CLK_PLL_SR_REG & CY_CLK_PLL_LOCK_STATUS))
 118   3                  {
 119   4                      if(0u != (CY_CLK_PLL_SR_REG & CY_CLK_PLL_LOCK_STATUS))
 120   4                      {
 121   5                          status = CYRET_SUCCESS;
 122   5                          break;
 123   5                      }
 124   4                  }
 125   3              }
 126   2      
 127   2      
 128   2              /* Restore 100 KHz ILO, FTW interval, enable and interrupt enable */
 129   2              if(0u == (iloEnableState & ILO_CONTROL_100KHZ_ON))
 130   2              {
 131   3                  CyILO_Stop100K();
 132   3              }
 133   2              CY_PM_TW_CFG0_REG = pmTwCfg0State;
 134   2              CY_PM_TW_CFG2_REG = pmTwCfg2State;
 135   2          }
 136   1      
 137   1          return(status);
 138   1      }
 139          
 140          
 141          /*******************************************************************************
 142          * Function Name: CyPLL_OUT_Stop
 143          ********************************************************************************
 144          *
 145          * Summary:
 146          *  Disables the PLL.
 147          *
 148          * Parameters:
 149          *  None
 150          *
 151          * Return:
 152          *  None
 153          *
 154          *******************************************************************************/
 155          void CyPLL_OUT_Stop(void) 
 156          {
 157   1          CY_CLK_PLL_CFG0_REG &= ((uint8)(~CY_CLK_PLL_ENABLE));
 158   1      }
 159          
 160          
 161          /*******************************************************************************
 162          * Function Name: CyPLL_OUT_SetPQ
 163          ********************************************************************************
 164          *
 165          * Summary:
 166          *  Sets the P and Q dividers and the charge pump current.
 167          *  The Frequency Out will be P/Q * Frequency In.
 168          *  The PLL must be disabled before calling this function.
 169          *
 170          * Parameters:
 171          *  uint8 pDiv:
 172          *   Valid range [8 - 255].
 173          *
 174          *  uint8 qDiv:
 175          *   Valid range [1 - 16]. Input Frequency / Q must be in range of 1 to 3 MHz.
 176          
 177          *  uint8 current:
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 4   

 178          *   Valid range [1 - 7]. Charge pump current in uA. Refer to the device TRM and
 179          *   datasheet for more information.
 180          *
 181          * Return:
 182          *  None
 183          *
 184          * Side Effects:
 185          *  If as result of this function execution the CPU clock frequency is increased
 186          *  then the number of clock cycles the cache will wait before it samples data
 187          *  coming back from Flash must be adjusted by calling CyFlash_SetWaitCycles()
 188          *  with appropriate parameter. It can be optionally called if CPU clock
 189          *  frequency is lowered in order to improve CPU performance.
 190          *  See CyFlash_SetWaitCycles() description for more information.
 191          *
 192          *******************************************************************************/
 193          void CyPLL_OUT_SetPQ(uint8 pDiv, uint8 qDiv, uint8 current) 
 194          {
 195   1          /* Halt CPU in debug mode if PLL is enabled */
 196   1          CYASSERT(0u == (CY_CLK_PLL_CFG0_REG & CY_CLK_PLL_ENABLE));
 197   1      
 198   1          if((pDiv    >= CY_CLK_PLL_MIN_P_VALUE  ) &&
 199   1             (qDiv    <= CY_CLK_PLL_MAX_Q_VALUE  ) && (qDiv    >= CY_CLK_PLL_MIN_Q_VALUE  ) &&
 200   1             (current >= CY_CLK_PLL_MIN_CUR_VALUE) && (current <= CY_CLK_PLL_MAX_CUR_VALUE))
 201   1          {
 202   2              /* Set new values */
 203   2              CY_CLK_PLL_P_REG = pDiv;
 204   2              CY_CLK_PLL_Q_REG = ((uint8)(qDiv - 1u));
 205   2              CY_CLK_PLL_CFG1_REG = (CY_CLK_PLL_CFG1_REG & CY_CLK_PLL_CURRENT_MASK) |
 206   2                                      ((uint8)(((uint8)(current - 1u)) << CY_CLK_PLL_CURRENT_POSITION));
 207   2          }
 208   1          else
 209   1          {
 210   2              /***********************************************************************
 211   2              * Halt CPU in debug mode if:
 212   2              * - P divider is less than required
 213   2              * - Q divider is out of range
 214   2              * - pump current is out of range
 215   2              ***********************************************************************/
 216   2              CYASSERT(0u != 0u);
 217   2          }
 218   1      
 219   1      }
 220          
 221          
 222          /*******************************************************************************
 223          * Function Name: CyPLL_OUT_SetSource
 224          ********************************************************************************
 225          *
 226          * Summary:
 227          *  Sets the input clock source to the PLL. The PLL must be disabled before
 228          *  calling this function.
 229          *
 230          * Parameters:
 231          *   source: One of the three available PLL clock sources
 232          *            0 :        IMO
 233          *            1 :        MHz Crystal
 234          *            2 :        DSI
 235          *
 236          * Return:
 237          *  None
 238          *
 239          * Side Effects:
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 5   

 240          *  If as result of this function execution the CPU clock frequency is increased
 241          *  then the number of clock cycles the cache will wait before it samples data
 242          *  coming back from Flash must be adjusted by calling CyFlash_SetWaitCycles()
 243          *  with appropriate parameter. It can be optionally called if CPU clock
 244          *  frequency is lowered in order to improve CPU performance.
 245          *  See CyFlash_SetWaitCycles() description for more information.
 246          *
 247          *******************************************************************************/
 248          void CyPLL_OUT_SetSource(uint8 source) 
 249          {
 250   1          /* Halt CPU in debug mode if PLL is enabled */
 251   1          CYASSERT(0u == (CY_CLK_PLL_CFG0_REG & CY_CLK_PLL_ENABLE));
 252   1      
 253   1          switch(source)
 254   1          {
 255   2              case CY_PLL_SOURCE_IMO:
 256   2              case CY_PLL_SOURCE_XTAL:
 257   2              case CY_PLL_SOURCE_DSI:
 258   2                  CY_LIB_CLKDIST_CR_REG = ((CY_LIB_CLKDIST_CR_REG & CY_LIB_CLKDIST_CR_PLL_SCR_MASK) | source);
 259   2              break;
 260   2      
 261   2              default:
 262   2                  CYASSERT(0u != 0u);
 263   2              break;
 264   2          }
 265   1      }
 266          
 267          
 268          /*******************************************************************************
 269          * Function Name: CyIMO_Start
 270          ********************************************************************************
 271          *
 272          * Summary:
 273          *  Enables the IMO. Optionally waits at least 6 us for it to settle.
 274          *
 275          * Parameters:
 276          *  uint8 wait:
 277          *   0: Return immediately after configuration
 278          *   1: Wait for at least 6 us for the IMO to settle.
 279          *
 280          * Return:
 281          *  None
 282          *
 283          * Side Effects:
 284          *  If wait is enabled: This function wses the Fast Time Wheel to time the wait.
 285          *  Any other use of the Fast Time Wheel will be stopped during the period of
 286          *  this function and then restored. This function also uses the 100 KHz ILO.
 287          *  If not enabled, this function will enable the 100 KHz ILO for the period of
 288          *  this function.
 289          *
 290          *  No changes to the setup of the ILO, Fast Time Wheel, Central Time Wheel or
 291          *  Once Per Second interrupt may be made by interrupt routines during the period
 292          *  of this function execution. The current operation of the ILO, Central Time
 293          *  Wheel and Once Per Second interrupt are maintained during the operation of
 294          *  this function provided the reading of the Power Manager Interrupt Status
 295          *  Register is only done using the CyPmReadStatus() function.
 296          *
 297          *******************************************************************************/
 298          void CyIMO_Start(uint8 wait) 
 299          {
 300   1          uint8 pmFtwCfg2Reg;
 301   1          uint8 pmFtwCfg0Reg;
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 6   

 302   1          uint8 iloControlReg;
 303   1      
 304   1          /* Set the bit to enable the clock. */
 305   1          PM_ACT_CFG0 |= IMO_PM_ENABLE;
 306   1      
 307   1          /* Wait for 6 us */
 308   1          if(0u != wait)
 309   1          {
 310   2              /* Need to turn on the 100KHz ILO if it happens to not already be running.*/
 311   2              iloControlReg = SLOWCLK_ILO_CR0;
 312   2      
 313   2              if(0u == (iloControlReg & ILO_CONTROL_100KHZ_ON))
 314   2              {
 315   3                  CyILO_Start100K();
 316   3              }
 317   2      
 318   2              /* Use ILO 100 KHz */
 319   2              pmFtwCfg2Reg = PM_TW_CFG2;
 320   2              pmFtwCfg0Reg = PM_TW_CFG0;
 321   2      
 322   2              /* FTW_EN (bit 0) must be clear to change the period*/
 323   2              PM_TW_CFG2 &= FTW_CLEAR_FTW_BITS;
 324   2      
 325   2              /* Set the FTW interval of 1 100KHz ILO clocks
 326   2              Should result in status getting set at a (100/1)KHz rate*/
 327   2              PM_TW_CFG0 = 0u;
 328   2      
 329   2              /* Enable FTW, but not the interrupt */
 330   2              PM_TW_CFG2 = FTW_ENABLE;
 331   2      
 332   2              /* Read FTW value */
 333   2              while (CyPmReadStatus(CY_PM_FTW_INT) == 0u)
 334   2              {
 335   3                  /* Wait for the interrupt status */
 336   3              }
 337   2      
 338   2              /* Reset the clock */
 339   2              if(0u == (iloControlReg & ILO_CONTROL_100KHZ_ON))
 340   2              {
 341   3                  CyILO_Stop100K();
 342   3              }
 343   2      
 344   2              /* Restore the FTW */
 345   2              PM_TW_CFG0 = pmFtwCfg0Reg;
 346   2              PM_TW_CFG2 = pmFtwCfg2Reg;
 347   2          }
 348   1      }
 349          
 350          
 351          /*******************************************************************************
 352          * Function Name: CyIMO_Stop
 353          ********************************************************************************
 354          *
 355          * Summary:
 356          *   Disables the IMO.
 357          *
 358          * Parameters:
 359          *  None
 360          *
 361          * Return:
 362          *  None
 363          *
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 7   

 364          *******************************************************************************/
 365          void CyIMO_Stop(void) 
 366          {
 367   1          /* Clear the bit to disable the clock. */
 368   1          PM_ACT_CFG0 &= ((uint8)(~IMO_PM_ENABLE));
 369   1      }
 370          
 371          
 372          /*******************************************************************************
 373          * Function Name: CyUSB_PowerOnCheck
 374          ********************************************************************************
 375          *
 376          * Summary:
 377          *  Returns the USB power status value. A private function to cy_boot.
 378          *
 379          * Parameters:
 380          *   None
 381          *
 382          * Return:
 383          *   uint8: one if the USB is enabled, 0 if not enabled.
 384          *
 385          *******************************************************************************/
 386          static uint8 CyUSB_PowerOnCheck(void)  
 387          {
 388   1          uint8 poweredOn = 0u;
 389   1      
 390   1          /* Check whether device is in Active or AltActiv and if USB is powered on */
 391   1          if((((CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_MASK) == CY_PM_MODE_CSR_ACTIVE ) &&
 392   1             (0u != (CY_PM_ACT_CFG5_REG & CY_ACT_USB_ENABLED     )))  ||
 393   1             (((CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_MASK) == CY_PM_MODE_CSR_ALT_ACT) &&
 394   1             (0u != (CY_PM_STBY_CFG5_REG & CY_ALT_ACT_USB_ENABLED))))
 395   1          {
 396   2              poweredOn = 1u;
 397   2          }
 398   1      
 399   1          return (poweredOn);
 400   1      }
 401          
 402          
 403          /*******************************************************************************
 404          * Function Name: CyIMO_SetTrimValue
 405          ********************************************************************************
 406          *
 407          * Summary:
 408          *  Sets the IMO factory trim values.
 409          *
 410          * Parameters:
 411          *  uint8 freq - frequency for which trims must be set
 412          *
 413          * Return:
 414          *  None
 415          *
 416          *******************************************************************************/
 417          static void CyIMO_SetTrimValue(uint8 freq) 
 418          {
 419   1          uint8 usb_power_on = CyUSB_PowerOnCheck();
 420   1      
 421   1          /* If USB is powered */
 422   1          if(usb_power_on == 1u)
 423   1          {
 424   2              /* Unlock USB write */
 425   2              CY_USB_CR1 &= ((uint8)(~CLOCK_USB_ENABLE));
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 8   

 426   2          }
 427   1          switch(freq)
 428   1          {
 429   2          case CY_IMO_FREQ_3MHZ:
 430   2              IMO_TR1 = CY_GET_XTND_REG8(FLSHID_CUST_TABLES_IMO_3MHZ_PTR);
 431   2              break;
 432   2      
 433   2          case CY_IMO_FREQ_6MHZ:
 434   2              IMO_TR1 = CY_GET_XTND_REG8(FLSHID_CUST_TABLES_IMO_6MHZ_PTR);
 435   2              break;
 436   2      
 437   2          case CY_IMO_FREQ_12MHZ:
 438   2              IMO_TR1 = CY_GET_XTND_REG8(FLSHID_CUST_TABLES_IMO_12MHZ_PTR);
 439   2              break;
 440   2      
 441   2          case CY_IMO_FREQ_24MHZ:
 442   2              IMO_TR1 = CY_GET_XTND_REG8(FLSHID_CUST_TABLES_IMO_24MHZ_PTR);
 443   2              break;
 444   2      
 445   2          case CY_IMO_FREQ_48MHZ:
 446   2              IMO_TR1 = CY_GET_XTND_REG8(FLSHID_MFG_CFG_IMO_TR1_PTR);
 447   2              break;
 448   2      
 449   2          /* The IMO frequencies above 48 MHz are not supported by PSoC5 */
 450   2          #if(!CY_PSOC5A)
 451   2      
 452   2              case CY_IMO_FREQ_62MHZ:
 453   2                  IMO_TR1 = CY_GET_XTND_REG8(FLSHID_CUST_TABLES_IMO_67MHZ_PTR);
 454   2                  break;
 455   2      
 456   2          #endif  /* (!CY_PSOC5A) */
 457   2      
 458   2          case CY_IMO_FREQ_USB:
 459   2              IMO_TR1 = CY_GET_XTND_REG8(FLSHID_CUST_TABLES_IMO_USB_PTR);
 460   2      
 461   2              /* If USB is powered */
 462   2              if(usb_power_on == 1u)
 463   2              {
 464   3                  /* Lock the USB Oscillator */
 465   3                  CY_USB_CR1 |= CLOCK_USB_ENABLE;
 466   3              }
 467   2              break;
 468   2      
 469   2          default:
 470   2                  CYASSERT(0u != 0u);
 471   2              break;
 472   2          }
 473   1      
 474   1      }
 475          
 476          
 477          /*******************************************************************************
 478          * Function Name: CyIMO_SetFreq
 479          ********************************************************************************
 480          *
 481          * Summary:
 482          *  Sets the frequency of the IMO. Changes may be made while the IMO is running.
 483          *
 484          * Parameters:
 485          *  freq: Frequency of IMO operation
 486          *       CY_IMO_FREQ_3MHZ  to set  3   MHz
 487          *       CY_IMO_FREQ_6MHZ  to set  6   MHz
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 9   

 488          *       CY_IMO_FREQ_12MHZ to set 12   MHz
 489          *       CY_IMO_FREQ_24MHZ to set 24   MHz
 490          *       CY_IMO_FREQ_48MHZ to set 48   MHz
 491          *       CY_IMO_FREQ_62MHZ to set 62 MHz (unsupported by PSoC 5)
 492          *       CY_IMO_FREQ_USB   to set 24   MHz (Trimmed for USB operation)
 493          *
 494          * Return:
 495          *  None
 496          *
 497          * Side Effects:
 498          *  If as result of this function execution the CPU clock frequency is increased
 499          *  then the number of clock cycles the cache will wait before it samples data
 500          *  coming back from Flash must be adjusted by calling CyFlash_SetWaitCycles()
 501          *  with appropriate parameter. It can be optionally called if CPU clock
 502          *  frequency is lowered in order to improve CPU performance.
 503          *  See CyFlash_SetWaitCycles() description for more information.
 504          *
 505          *  When the USB setting is chosen, the USB clock locking circuit is enabled.
 506          *  Otherwise this circuit is disabled. The USB block must be powered before
 507          *  selecting the USB setting.
 508          *
 509          *******************************************************************************/
 510          void CyIMO_SetFreq(uint8 freq) 
 511          {
 512   1          uint8 currentFreq;
 513   1          uint8 nextFreq;
 514   1      
 515   1          /***************************************************************************
 516   1          * When changing the IMO frequency the Trim values must also be set
 517   1          * accordingly.This requires reading the current frequency. If the new
 518   1          * frequency is faster, then set the new trim and then change the frequency,
 519   1          * otherwise change the frequency and then set the new trim values.
 520   1          ***************************************************************************/
 521   1      
 522   1          currentFreq = CY_LIB_FASTCLK_IMO_CR_REG & ((uint8)(~CY_LIB_FASTCLK_IMO_CR_RANGE_MASK));
 523   1      
 524   1          /* Check if the requested frequency is USB. */
 525   1          nextFreq = (freq == CY_IMO_FREQ_USB) ? CY_IMO_FREQ_24MHZ : freq;
 526   1      
 527   1          switch (currentFreq)
 528   1          {
 529   2          case 0u:
 530   2              currentFreq = CY_IMO_FREQ_12MHZ;
 531   2              break;
 532   2      
 533   2          case 1u:
 534   2              currentFreq = CY_IMO_FREQ_6MHZ;
 535   2              break;
 536   2      
 537   2          case 2u:
 538   2              currentFreq = CY_IMO_FREQ_24MHZ;
 539   2              break;
 540   2      
 541   2          case 3u:
 542   2              currentFreq = CY_IMO_FREQ_3MHZ;
 543   2              break;
 544   2      
 545   2          case 4u:
 546   2              currentFreq = CY_IMO_FREQ_48MHZ;
 547   2              break;
 548   2      
 549   2          /* The IMO frequencies above 48 MHz are not supported by PSoC5 */
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 10  

 550   2          #if(!CY_PSOC5A)
 551   2      
 552   2              case 5u:
 553   2                  currentFreq = CY_IMO_FREQ_62MHZ;
 554   2                  break;
 555   2      
 556   2          #endif  /* (!CY_PSOC5A) */
 557   2      
 558   2          default:
 559   2              CYASSERT(0u != 0u);
 560   2              break;
 561   2          }
 562   1      
 563   1          if (nextFreq >= currentFreq)
 564   1          {
 565   2              /* Set the new trim first */
 566   2              CyIMO_SetTrimValue(freq);
 567   2          }
 568   1      
 569   1          /* Set the usbclk_on bit when using CY_IMO_FREQ_USB, if not clear it */
 570   1          switch(freq)
 571   1          {
 572   2          case CY_IMO_FREQ_3MHZ:
 573   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 574   2                  CLOCK_IMO_3MHZ_VALUE) & ((uint8)(~FASTCLK_IMO_USBCLK_ON_SET));
 575   2              break;
 576   2      
 577   2          case CY_IMO_FREQ_6MHZ:
 578   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 579   2                  CLOCK_IMO_6MHZ_VALUE) & ((uint8)(~FASTCLK_IMO_USBCLK_ON_SET));
 580   2              break;
 581   2      
 582   2          case CY_IMO_FREQ_12MHZ:
 583   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 584   2                  CLOCK_IMO_12MHZ_VALUE) & ((uint8)(~FASTCLK_IMO_USBCLK_ON_SET));
 585   2              break;
 586   2      
 587   2          case CY_IMO_FREQ_24MHZ:
 588   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 589   2                  CLOCK_IMO_24MHZ_VALUE) & ((uint8)(~FASTCLK_IMO_USBCLK_ON_SET));
 590   2              break;
 591   2      
 592   2          case CY_IMO_FREQ_48MHZ:
 593   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 594   2                  CLOCK_IMO_48MHZ_VALUE) & ((uint8)(~FASTCLK_IMO_USBCLK_ON_SET));
 595   2              break;
 596   2      
 597   2          /* The IMO frequencies above 48 MHz are not supported by PSoC5 */
 598   2          #if(!CY_PSOC5A)
 599   2      
 600   2          case CY_IMO_FREQ_62MHZ:
 601   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 602   2                  CLOCK_IMO_62MHZ_VALUE) & ((uint8)(~FASTCLK_IMO_USBCLK_ON_SET));
 603   2              break;
 604   2      
 605   2          #endif  /* (!CY_PSOC5A) */
 606   2      
 607   2          case CY_IMO_FREQ_USB:
 608   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 609   2                  CLOCK_IMO_24MHZ_VALUE) | FASTCLK_IMO_USBCLK_ON_SET;
 610   2              break;
 611   2      
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 11  

 612   2          default:
 613   2              CYASSERT(0u != 0u);
 614   2              break;
 615   2          }
 616   1      
 617   1          /* Turn on the IMO Doubler, if switching to CY_IMO_FREQ_USB */
 618   1          if (freq == CY_IMO_FREQ_USB)
 619   1          {
 620   2              CyIMO_EnableDoubler();
 621   2          }
 622   1          else
 623   1          {
 624   2              CyIMO_DisableDoubler();
 625   2          }
 626   1      
 627   1          if (nextFreq < currentFreq)
 628   1          {
 629   2              /* Set the new trim after setting the frequency */
 630   2              CyIMO_SetTrimValue(freq);
 631   2          }
 632   1      }
 633          
 634          
 635          /*******************************************************************************
 636          * Function Name: CyIMO_SetSource
 637          ********************************************************************************
 638          *
 639          * Summary:
 640          *  Sets the source of the clock output from the IMO block.
 641          *
 642          *  The output from the IMO is by default the IMO itself. Optionally the MHz
 643          *  Crystal or a DSI input can be the source of the IMO output instead.
 644          *
 645          * Parameters:
 646          *   source, CY_IMO_SOURCE_DSI to set the DSI as source.
 647          *           CY_IMO_SOURCE_XTAL to set the MHz as source.
 648          *           CY_IMO_SOURCE_IMO to set the IMO itself.
 649          *
 650          * Return:
 651          *  None
 652          *
 653          * Side Effects:
 654          *  If as result of this function execution the CPU clock frequency is increased
 655          *  then the number of clock cycles the cache will wait before it samples data
 656          *  coming back from Flash must be adjusted by calling CyFlash_SetWaitCycles()
 657          *  with appropriate parameter. It can be optionally called if CPU clock
 658          *  frequency is lowered in order to improve CPU performance.
 659          *  See CyFlash_SetWaitCycles() description for more information.
 660          *
 661          *******************************************************************************/
 662          void CyIMO_SetSource(uint8 source) 
 663          {
 664   1          switch(source)
 665   1          {
 666   2          case CY_IMO_SOURCE_DSI:
 667   2              CY_LIB_CLKDIST_CR_REG     &= ((uint8)(~CY_LIB_CLKDIST_CR_IMO2X));
 668   2              CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_IMO;
 669   2              break;
 670   2      
 671   2          case CY_IMO_SOURCE_XTAL:
 672   2              CY_LIB_CLKDIST_CR_REG     |= CY_LIB_CLKDIST_CR_IMO2X;
 673   2              CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_IMO;
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 12  

 674   2              break;
 675   2      
 676   2          case CY_IMO_SOURCE_IMO:
 677   2              CY_LIB_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_LIB_FASTCLK_IMO_IMO));
 678   2              break;
 679   2      
 680   2          default:
 681   2              /* Incorrect source value */
 682   2              CYASSERT(0u != 0u);
 683   2              break;
 684   2          }
 685   1      }
 686          
 687          
 688          /*******************************************************************************
 689          * Function Name: CyIMO_EnableDoubler
 690          ********************************************************************************
 691          *
 692          * Summary:
 693          *  Enables the IMO doubler.  The 2x frequency clock is used to convert a 24 MHz
 694          *  input to a 48 MHz output for use by the USB block.
 695          *
 696          * Parameters:
 697          *  None
 698          *
 699          * Return:
 700          *  None
 701          *
 702          *******************************************************************************/
 703          void CyIMO_EnableDoubler(void) 
 704          {
 705   1          /* Set the FASTCLK_IMO_CR_PTR regigster's 4th bit */
 706   1          CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_DOUBLER;
 707   1      }
 708          
 709          
 710          /*******************************************************************************
 711          * Function Name: CyIMO_DisableDoubler
 712          ********************************************************************************
 713          *
 714          * Summary:
 715          *   Disables the IMO doubler.
 716          *
 717          * Parameters:
 718          *  None
 719          *
 720          * Return:
 721          *  None
 722          *
 723          *******************************************************************************/
 724          void CyIMO_DisableDoubler(void) 
 725          {
 726   1          CY_LIB_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_LIB_FASTCLK_IMO_DOUBLER));
 727   1      }
 728          
 729          
 730          /*******************************************************************************
 731          * Function Name: CyMasterClk_SetSource
 732          ********************************************************************************
 733          *
 734          * Summary:
 735          *  Sets the source of the master clock.
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 13  

 736          *
 737          * Parameters:
 738          *   source: One of the four available Master clock sources.
 739          *     CY_MASTER_SOURCE_IMO
 740          *     CY_MASTER_SOURCE_PLL
 741          *     CY_MASTER_SOURCE_XTAL
 742          *     CY_MASTER_SOURCE_DSI
 743          *
 744          * Return:
 745          *  None
 746          *
 747          * Side Effects:
 748          *  The current source and the new source must both be running and stable before
 749          *  calling this function.
 750          *
 751          *  If as result of this function execution the CPU clock frequency is increased
 752          *  then the number of clock cycles the cache will wait before it samples data
 753          *  coming back from Flash must be adjusted by calling CyFlash_SetWaitCycles()
 754          *  with appropriate parameter. It can be optionally called if CPU clock
 755          *  frequency is lowered in order to improve CPU performance.
 756          *  See CyFlash_SetWaitCycles() description for more information.
 757          *
 758          *******************************************************************************/
 759          void CyMasterClk_SetSource(uint8 source) 
 760          {
 761   1          #if(CY_PSOC5A)
              
                      uint8 masterReg0;
              
                      /* Read the current setting */
                      masterReg0 = CY_LIB_CLKDIST_MSTR0_REG;
              
                      /* Write a non-zero period to the master mux clock divider */
                      if (masterReg0 == 0x00u)
                      {
                          CY_LIB_CLKDIST_MSTR0_REG = 3u;
                      }
              
                  #endif  /* (CY_PSOC5A) */
 775   1      
 776   1          CY_LIB_CLKDIST_MSTR1_REG = (CY_LIB_CLKDIST_MSTR1_REG & MASTER_CLK_SRC_CLEAR) |
 777   1                                      (source & ((uint8)(~MASTER_CLK_SRC_CLEAR)));
 778   1      
 779   1          #if(CY_PSOC5A)
              
                      /* Restore zero period (if desired) to the master mux clock divider */
                      if (masterReg0 == 0x00u)
                      {
                          CY_LIB_CLKDIST_MSTR0_REG = 0u;
                      }
              
                  #endif  /* (CY_PSOC5A) */
 788   1      }
 789          
 790          
 791          /*******************************************************************************
 792          * Function Name: CyMasterClk_SetDivider
 793          ********************************************************************************
 794          *
 795          * Summary:
 796          *  Sets the divider value used to generate Master Clock.
 797          *
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 14  

 798          * Parameters:
 799          *  uint8 divider:
 800          *   Valid range [0-255]. The clock will be divided by this value + 1.
 801          *   For example to divide by 2 this parameter should be set to 1.
 802          *
 803          * Return:
 804          *  None
 805          *
 806          * Side Effects:
 807          *  If as result of this function execution the CPU clock frequency is increased
 808          *  then the number of clock cycles the cache will wait before it samples data
 809          *  coming back from Flash must be adjusted by calling CyFlash_SetWaitCycles()
 810          *  with appropriate parameter. It can be optionally called if CPU clock
 811          *  frequency is lowered in order to improve CPU performance.
 812          *  See CyFlash_SetWaitCycles() description for more information.
 813          *
 814          *  When changing the Master or Bus clock divider value from div-by-n to div-by-1
 815          *  the first clock cycle output after the div-by-1 can be up to 4 ns shorter
 816          *  than the final/expected div-by-1 period.
 817          *
 818          *******************************************************************************/
 819          void CyMasterClk_SetDivider(uint8 divider) 
 820          {
 821   1          CY_LIB_CLKDIST_MSTR0_REG = divider;
 822   1      }
 823          
 824          
 825          /*******************************************************************************
 826          * Function Name: CyBusClk_Internal_SetDivider
 827          ********************************************************************************
 828          *
 829          * Summary:
 830          *  Function used by CyBusClk_SetDivider(). For internal use only.
 831          *
 832          * Parameters:
 833          *   divider: Valid range [0-65535].
 834          *   The clock will be divided by this value + 1.
 835          *   For example to divide by 2 this parameter should be set to 1.
 836          *
 837          * Return:
 838          *  None
 839          *
 840          *******************************************************************************/
 841          static void CyBusClk_Internal_SetDivider(uint16 divider)
 842          {
 843   1          /* Mask bits to enable shadow loads  */
 844   1          CY_LIB_CLKDIST_AMASK_REG &= CY_LIB_CLKDIST_AMASK_MASK;
 845   1          CY_LIB_CLKDIST_DMASK_REG  = CY_LIB_CLKDIST_DMASK_MASK;
 846   1      
 847   1          /* Enable mask bits to enable shadow loads */
 848   1          CY_LIB_CLKDIST_BCFG2_REG |= CY_LIB_CLKDIST_BCFG2_MASK;
 849   1      
 850   1          /* Update Shadow Divider Value Register with the new divider */
 851   1          CY_LIB_CLKDIST_WRK_LSB_REG = LO8(divider);
 852   1          CY_LIB_CLKDIST_WRK_MSB_REG = HI8(divider);
 853   1      
 854   1      
 855   1          /***************************************************************************
 856   1          * Copy shadow value defined in Shadow Divider Value Register
 857   1          * (CY_LIB_CLKDIST_WRK_LSB_REG and CY_LIB_CLKDIST_WRK_MSB_REG) to all
 858   1          * dividers selected in Analog and Digital Clock Mask Registers
 859   1          * (CY_LIB_CLKDIST_AMASK_REG and CY_LIB_CLKDIST_DMASK_REG).
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 15  

 860   1          ***************************************************************************/
 861   1          CY_LIB_CLKDIST_LD_REG |= CY_LIB_CLKDIST_LD_LOAD;
 862   1      }
 863          
 864          
 865          /*******************************************************************************
 866          * Function Name: CyBusClk_SetDivider
 867          ********************************************************************************
 868          *
 869          * Summary:
 870          *  Sets the divider value used to generate Bus Clock.
 871          *
 872          * Parameters:
 873          *  divider: Valid range [0-65535]. The clock will be divided by this value + 1.
 874          *  For example to divide by 2 this parameter should be set to 1.
 875          *
 876          * Return:
 877          *  None
 878          *
 879          * Side Effects:
 880          *  If as result of this function execution the CPU clock frequency is increased
 881          *  then the number of clock cycles the cache will wait before it samples data
 882          *  coming back from Flash must be adjusted by calling CyFlash_SetWaitCycles()
 883          *  with appropriate parameter. It can be optionally called if CPU clock
 884          *  frequency is lowered in order to improve CPU performance.
 885          *  See CyFlash_SetWaitCycles() description for more information.
 886          *
 887          *******************************************************************************/
 888          void CyBusClk_SetDivider(uint16 divider) 
 889          {
 890   1          uint8  masterClkDiv;
 891   1          uint16 busClkDiv;
 892   1          uint8 interruptState;
 893   1      
 894   1          interruptState = CyEnterCriticalSection();
 895   1      
 896   1          /* Work around to set the bus clock divider value */
 897   1          busClkDiv = ((uint16)(((uint16)(CY_LIB_CLKDIST_BCFG_MSB_REG)) << 8u)) | CY_LIB_CLKDIST_BCFG_LSB_REG;
 898   1      
 899   1          if ((divider == 0u) || (busClkDiv == 0u))
 900   1          {
 901   2              /* Save away the master clock divider value */
 902   2              masterClkDiv = CY_LIB_CLKDIST_MSTR0_REG;
 903   2      
 904   2              if (masterClkDiv < CY_LIB_CLKDIST_MASTERCLK_DIV)
 905   2              {
 906   3                  /* Set master clock divider to 7 */
 907   3                  CyMasterClk_SetDivider(CY_LIB_CLKDIST_MASTERCLK_DIV);
 908   3              }
 909   2      
 910   2              if (divider == 0u)
 911   2              {
 912   3                  /* Set the SSS bit and the divider register desired value */
 913   3                  CY_LIB_CLKDIST_BCFG2_REG |= CY_LIB_CLKDIST_BCFG2_SSS;
 914   3                  CyBusClk_Internal_SetDivider(divider);
 915   3              }
 916   2              else
 917   2              {
 918   3                  CyBusClk_Internal_SetDivider(divider);
 919   3                  CY_LIB_CLKDIST_BCFG2_REG &= ((uint8)(~CY_LIB_CLKDIST_BCFG2_SSS));
 920   3              }
 921   2      
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 16  

 922   2              /* Restore the master clock */
 923   2              CyMasterClk_SetDivider(masterClkDiv);
 924   2          }
 925   1          else
 926   1          {
 927   2              CyBusClk_Internal_SetDivider(divider);
 928   2          }
 929   1      
 930   1          CyExitCriticalSection(interruptState);
 931   1      }
 932          
 933          
 934          #if(CY_PSOC3)
 935          
 936              /*******************************************************************************
 937              * Function Name: CyCpuClk_SetDivider
 938              ********************************************************************************
 939              *
 940              * Summary:
 941              *  Sets the divider value used to generate the CPU Clock. Only applicable for
 942              *  PSoC 3 parts.
 943              *
 944              * Parameters:
 945              *  divider: Valid range [0-15]. The clock will be divided by this value + 1.
 946              *  For example to divide by 2 this parameter should be set to 1.
 947              *
 948              * Return:
 949              *  None
 950              *
 951              * Side Effects:
 952              *  If as result of this function execution the CPU clock frequency is increased
 953              *  then the number of clock cycles the cache will wait before it samples data
 954              *  coming back from Flash must be adjusted by calling CyFlash_SetWaitCycles()
 955              *  with appropriate parameter. It can be optionally called if CPU clock
 956              *  frequency is lowered in order to improve CPU performance.
 957              *  See CyFlash_SetWaitCycles() description for more information.
 958              *
 959              *******************************************************************************/
 960              void CyCpuClk_SetDivider(uint8 divider) 
 961              {
 962   1                  CLKDIST_MSTR1 = (CLKDIST_MSTR1 & CLKDIST_MSTR1_DIV_CLEAR) |
 963   1                                      ((uint8)(divider << CLKDIST_DIV_POSITION));
 964   1          }
 965          
 966          #endif /* (CY_PSOC3) */
 967          
 968          
 969          /*******************************************************************************
 970          * Function Name: CyUsbClk_SetSource
 971          ********************************************************************************
 972          *
 973          * Summary:
 974          *  Sets the source of the USB clock.
 975          *
 976          * Parameters:
 977          *  source: One of the four available USB clock sources
 978          *             USB_CLK_IMO2X     - IMO 2x
 979          *             USB_CLK_IMO       - IMO
 980          *             USB_CLK_PLL       - PLL
 981          *             USB_CLK_DSI       - DSI
 982          *
 983          * Return:
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 17  

 984          *  None
 985          *
 986          *******************************************************************************/
 987          void CyUsbClk_SetSource(uint8 source) 
 988          {
 989   1          CLKDIST_UCFG = (CLKDIST_UCFG & ((uint8)(~USB_CLKDIST_CONFIG_MASK))) |
 990   1                              (USB_CLKDIST_CONFIG_MASK & source);
 991   1      }
 992          
 993          
 994          /*******************************************************************************
 995          * Function Name: CyILO_Start1K
 996          ********************************************************************************
 997          *
 998          * Summary:
 999          *  Enables the ILO 1 KHz oscillator.
1000          *
1001          *  Note The ILO 1 KHz oscillator is always enabled by default, regardless of the
1002          *  selection in the Clock Editor. Therefore, this API is only needed if the
1003          *  oscillator was turned off manually.
1004          *
1005          * Parameters:
1006          *  None
1007          *
1008          * Return:
1009          *  None
1010          *
1011          *******************************************************************************/
1012          void CyILO_Start1K(void) 
1013          {
1014   1          /* Set the bit 1 of ILO RS */
1015   1          SLOWCLK_ILO_CR0 |= ILO_CONTROL_1KHZ_ON;
1016   1      }
1017          
1018          
1019          /*******************************************************************************
1020          * Function Name: CyILO_Stop1K
1021          ********************************************************************************
1022          *
1023          * Summary:
1024          *  Disables the ILO 1 KHz oscillator.
1025          *
1026          *  Note The ILO 1 KHz oscillator must be enabled if Sleep or Hibernate low power
1027          *  mode APIs are expected to be used. For more information, refer to the Power
1028          *  Management section of this document.
1029          *
1030          * Parameters:
1031          *  None
1032          *
1033          * Return:
1034          *  None
1035          *
1036          * Side Effects:
1037          *  PSoC5: Stopping the ILO 1 kHz could break the active WDT functionality.
1038          *
1039          *******************************************************************************/
1040          void CyILO_Stop1K(void) 
1041          {
1042   1          /* Clear the bit 1 of ILO RS */
1043   1          SLOWCLK_ILO_CR0 &= ((uint8)(~ILO_CONTROL_1KHZ_ON));
1044   1      }
1045          
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 18  

1046          
1047          /*******************************************************************************
1048          * Function Name: CyILO_Start100K
1049          ********************************************************************************
1050          *
1051          * Summary:
1052          *  Enables the ILO 100 KHz oscillator.
1053          *
1054          * Parameters:
1055          *  None
1056          *
1057          * Return:
1058          *  None
1059          *
1060          *******************************************************************************/
1061          void CyILO_Start100K(void) 
1062          {
1063   1          /* Set the bit 2 of ILO RS */
1064   1          SLOWCLK_ILO_CR0 |= ILO_CONTROL_100KHZ_ON;
1065   1      }
1066          
1067          
1068          /*******************************************************************************
1069          * Function Name: CyILO_Stop100K
1070          ********************************************************************************
1071          *
1072          * Summary:
1073          *  Disables the ILO 100 KHz oscillator.
1074          *
1075          * Parameters:
1076          *  None
1077          *
1078          * Return:
1079          *  None
1080          *
1081          *******************************************************************************/
1082          void CyILO_Stop100K(void) 
1083          {
1084   1          /* Clear the bit 2 of ILO RS */
1085   1          SLOWCLK_ILO_CR0 &= ((uint8)(~ILO_CONTROL_100KHZ_ON));
1086   1      }
1087          
1088          
1089          /*******************************************************************************
1090          * Function Name: CyILO_Enable33K
1091          ********************************************************************************
1092          *
1093          * Summary:
1094          *  Enables the ILO 33 KHz divider.
1095          *
1096          *  Note that the 33 KHz clock is generated from the 100 KHz oscillator,
1097          *  so it must also be running in order to generate the 33 KHz output.
1098          *
1099          * Parameters:
1100          *  None
1101          *
1102          * Return:
1103          *  None
1104          *
1105          *******************************************************************************/
1106          void CyILO_Enable33K(void) 
1107          {
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 19  

1108   1          /* Set the bit 5 of ILO RS */
1109   1          SLOWCLK_ILO_CR0 |= ILO_CONTROL_33KHZ_ON;
1110   1      }
1111          
1112          
1113          /*******************************************************************************
1114          * Function Name: CyILO_Disable33K
1115          ********************************************************************************
1116          *
1117          * Summary:
1118          *  Disables the ILO 33 KHz divider.
1119          *
1120          *  Note that the 33 KHz clock is generated from the 100 KHz oscillator, but this
1121          *  API does not disable the 100 KHz clock.
1122          *
1123          * Parameters:
1124          *  None
1125          *
1126          * Return:
1127          *  None
1128          *
1129          *******************************************************************************/
1130          void CyILO_Disable33K(void) 
1131          {
1132   1          /* Clear the bit 5 of ILO RS */
1133   1          SLOWCLK_ILO_CR0 &= ((uint8)(~ILO_CONTROL_33KHZ_ON));
1134   1      }
1135          
1136          
1137          /*******************************************************************************
1138          * Function Name: CyILO_SetSource
1139          ********************************************************************************
1140          *
1141          * Summary:
1142          *  Sets the source of the clock output from the ILO block.
1143          *
1144          * Parameters:
1145          *  source: One of the three available ILO output sources
1146          *       Value        Define                Source
1147          *       0            CY_ILO_SOURCE_100K    ILO 100 KHz
1148          *       1            CY_ILO_SOURCE_33K     ILO 33 KHz
1149          *       2            CY_ILO_SOURCE_1K      ILO 1 KHz
1150          *
1151          * Return:
1152          *  None
1153          *
1154          *******************************************************************************/
1155          void CyILO_SetSource(uint8 source) 
1156          {
1157   1          CLKDIST_CR = (CLKDIST_CR & CY_ILO_SOURCE_BITS_CLEAR) |
1158   1                          (((uint8) (source << 2u)) & ((uint8)(~CY_ILO_SOURCE_BITS_CLEAR)));
1159   1      }
1160          
1161          
1162          /*******************************************************************************
1163          * Function Name: CyILO_SetPowerMode
1164          ********************************************************************************
1165          *
1166          * Summary:
1167          *  Sets the power mode used by the ILO during power down. Allows for lower power
1168          *  down power usage resulting in a slower startup time.
1169          *
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 20  

1170          * Parameters:
1171          *  uint8 mode
1172          *   CY_ILO_FAST_START - Faster start-up, internal bias left on when powered down
1173          *   CY_ILO_SLOW_START - Slower start-up, internal bias off when powered down
1174          *
1175          * Return:
1176          *   Prevous power mode state.
1177          *
1178          *******************************************************************************/
1179          uint8 CyILO_SetPowerMode(uint8 mode) 
1180          {
1181   1          uint8 state;
1182   1      
1183   1          /* Get current state. */
1184   1          state = SLOWCLK_ILO_CR0;
1185   1      
1186   1          /* Set the the oscillator power mode. */
1187   1          if(mode != CY_ILO_FAST_START)
1188   1          {
1189   2              SLOWCLK_ILO_CR0 = (state | ILO_CONTROL_PD_MODE);
1190   2          }
1191   1          else
1192   1          {
1193   2              SLOWCLK_ILO_CR0 = (state & ((uint8)(~ILO_CONTROL_PD_MODE)));
1194   2          }
1195   1      
1196   1          /* Return the old mode. */
1197   1          return ((state & ILO_CONTROL_PD_MODE) >> ILO_CONTROL_PD_POSITION);
1198   1      }
1199          
1200          
1201          /*******************************************************************************
1202          * Function Name: CyXTAL_32KHZ_Start
1203          ********************************************************************************
1204          *
1205          * Summary:
1206          *  Enables the 32 KHz Crystal Oscillator.
1207          *
1208          * Parameters:
1209          *  None
1210          *
1211          * Return:
1212          *  None
1213          *
1214          *******************************************************************************/
1215          void CyXTAL_32KHZ_Start(void) 
1216          {
1217   1          volatile uint16 i;
1218   1      
1219   1          CY_CLK_XTAL32_TST_REG = CY_CLK_XTAL32_TST_DEFAULT;
1220   1          CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_STARTUP;
1221   1          CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1222   1                                      CY_CLK_XTAL32_CFG_LP_DEFAULT;
1223   1      
1224   1          #if(CY_PSOC3)
1225   1              CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_PDBEN;
1226   1          #endif  /* (CY_PSOC3) */
1227   1      
1228   1          /* Enable operation of the 32K Crystal Oscillator */
1229   1          CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_EN;
1230   1      
1231   1          for (i = 1000u; i > 0u; i--)
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 21  

1232   1          {
1233   2              if(0u != (CyXTAL_32KHZ_ReadStatus() & CY_XTAL32K_ANA_STAT))
1234   2              {
1235   3                  /* Ready - switch to the hign power mode */
1236   3                  (void) CyXTAL_32KHZ_SetPowerMode(0u);
1237   3      
1238   3                  break;
1239   3              }
1240   2              CyDelayUs(1u);
1241   2          }
1242   1      }
1243          
1244          
1245          /*******************************************************************************
1246          * Function Name: CyXTAL_32KHZ_Stop
1247          ********************************************************************************
1248          *
1249          * Summary:
1250          *  Disables the 32KHz Crystal Oscillator.
1251          *
1252          * Parameters:
1253          *  None
1254          *
1255          * Return:
1256          *  None
1257          *
1258          *******************************************************************************/
1259          void CyXTAL_32KHZ_Stop(void) 
1260          {
1261   1          CY_CLK_XTAL32_TST_REG  = CY_CLK_XTAL32_TST_DEFAULT;
1262   1          CY_CLK_XTAL32_TR_REG   = CY_CLK_XTAL32_TR_POWERDOWN;
1263   1          CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) | CY_CLK_XTAL3
             -2_CFG_LP_DEFAULT;
1264   1          CY_CLK_XTAL32_CR_REG &= ((uint8)(~(CY_CLK_XTAL32_CR_EN | CY_CLK_XTAL32_CR_LPM)));
1265   1      
1266   1          #if(CY_PSOC3)
1267   1              CY_CLK_XTAL32_CR_REG &= ((uint8)(~CY_CLK_XTAL32_CR_PDBEN));
1268   1          #endif  /* (CY_PSOC3) */
1269   1      }
1270          
1271          
1272          /*******************************************************************************
1273          * Function Name: CyXTAL_32KHZ_ReadStatus
1274          ********************************************************************************
1275          *
1276          * Summary:
1277          *  Returns status of the 32 KHz oscillator.
1278          *
1279          * Parameters:
1280          *  None
1281          *
1282          * Return:
1283          *  Value     Define                    Source
1284          *  20        CY_XTAL32K_ANA_STAT       Analog measurement
1285          *                                       1: Stable
1286          *                                       0: Not stable
1287          *
1288          *******************************************************************************/
1289          uint8 CyXTAL_32KHZ_ReadStatus(void) 
1290          {
1291   1          return(CY_CLK_XTAL32_CR_REG & CY_XTAL32K_ANA_STAT);
1292   1      }
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 22  

1293          
1294          
1295          /*******************************************************************************
1296          * Function Name: CyXTAL_32KHZ_SetPowerMode
1297          ********************************************************************************
1298          *
1299          * Summary:
1300          *  Sets the power mode for the 32 KHz oscillator used during sleep mode.
1301          *  Allows for lower power during sleep when there are fewer sources of noise.
1302          *  During active mode the oscillator is always run in high power mode.
1303          *
1304          * Parameters:
1305          *  uint8 mode
1306          *       0: High power mode
1307          *       1: Low power mode during sleep
1308          *
1309          * Return:
1310          *  Previous power mode.
1311          *
1312          *******************************************************************************/
1313          uint8 CyXTAL_32KHZ_SetPowerMode(uint8 mode) 
1314          {
1315   1          uint8 state = (0u != (CY_CLK_XTAL32_CR_REG & CY_CLK_XTAL32_CR_LPM)) ? 1u : 0u;
1316   1      
1317   1          CY_CLK_XTAL32_TST_REG = CY_CLK_XTAL32_TST_DEFAULT;
1318   1      
1319   1          if(1u == mode)
1320   1          {
1321   2              /* Low power mode during Sleep */
1322   2              CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_LOW_POWER;
1323   2              CyDelayUs(10u);
1324   2              CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) | CY_CLK_X
             -TAL32_CFG_LP_LOWPOWER;
1325   2              CyDelayUs(20u);
1326   2              CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_LPM;
1327   2          }
1328   1          else
1329   1          {
1330   2              /* High power mode */
1331   2              CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_HIGH_POWER;
1332   2              CyDelayUs(10u);
1333   2              CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) | CY_CLK_X
             -TAL32_CFG_LP_DEFAULT;
1334   2              CY_CLK_XTAL32_CR_REG &= ((uint8)(~CY_CLK_XTAL32_CR_LPM));
1335   2          }
1336   1      
1337   1          return(state);
1338   1      }
1339          
1340          
1341          /*******************************************************************************
1342          * Function Name: CyXTAL_Start
1343          ********************************************************************************
1344          *
1345          * Summary:
1346          *  Enables the megahertz crystal.
1347          *
1348          *  PSoC3:
1349          *  Waits until the XERR bit is low (no error) for a millisecond or until the
1350          *  number of milliseconds specified by the wait parameter has expired.
1351          *
1352          *  PSoC5:
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 23  

1353          *  Waits for CY_CLK_XMHZ_MIN_TIMEOUT milliseconds (or number of milliseconds
1354          *  specified by parameter if it is greater than CY_CLK_XMHZ_MIN_TIMEOUT. The
1355          *  XERR bit status is not checked.
1356          *
1357          * Parameters:
1358          *   wait: Valid range [0-255].
1359          *   This is the timeout value in milliseconds.
1360          *   The appropriate value is crystal specific.
1361          *
1362          * Return:
1363          *   CYRET_SUCCESS - Completed successfully
1364          *   CYRET_TIMEOUT - Timeout occurred without detecting a low value on XERR.
1365          *
1366          * Side Effects and Restrictions:
1367          *  If wait is enabled (non-zero wait). Uses the Fast Timewheel to time the wait.
1368          *  Any other use of the Fast Timewheel (FTW) will be stopped during the period
1369          *  of this function and then restored.
1370          *
1371          *  Uses the 100KHz ILO.  If not enabled, this function will enable the 100KHz
1372          *  ILO for the period of this function. No changes to the setup of the ILO,
1373          *  Fast Timewheel, Central Timewheel or Once Per Second interrupt may be made
1374          *  by interrupt routines during the period of this function.
1375          *
1376          *  The current operation of the ILO, Central Timewheel and Once Per Second
1377          *  interrupt are maintained during the operation of this function provided the
1378          *  reading of the Power Manager Interrupt Status Register is only done using the
1379          *  CyPmReadStatus() function.
1380          *
1381          *******************************************************************************/
1382          cystatus CyXTAL_Start(uint8 wait) 
1383          {
1384   1          cystatus status = CYRET_SUCCESS;
1385   1      
1386   1          #if(CY_PSOC5A)
                      volatile uint8  timeout = (wait < CY_CLK_XMHZ_MIN_TIMEOUT) ? CY_CLK_XMHZ_MIN_TIMEOUT : wait;
                  #else
1389   1              volatile uint8  timeout = wait;
1390   1          #endif  /* (CY_PSOC5A) */
1391   1      
1392   1          volatile uint8 count;
1393   1          uint8 iloEnableState;
1394   1          uint8 pmTwCfg0Tmp;
1395   1          uint8 pmTwCfg2Tmp;
1396   1      
1397   1      
1398   1          /* Enables the MHz crystal oscillator circuit  */
1399   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_ENABLE;
1400   1      
1401   1      
1402   1          if(wait > 0u)
1403   1          {
1404   2              /* Save 100 KHz ILO, FTW interval, enable and interrupt enable */
1405   2              iloEnableState = SLOWCLK_ILO_CR0;
1406   2              pmTwCfg0Tmp = CY_PM_TW_CFG0_REG;
1407   2              pmTwCfg2Tmp = CY_PM_TW_CFG2_REG;
1408   2      
1409   2              /* Set 250 us interval */
1410   2              CyPmFtwSetInterval(CY_CLK_XMHZ_FTW_INTERVAL);
1411   2              status = CYRET_TIMEOUT;
1412   2      
1413   2      
1414   2              for( ; timeout > 0u; timeout--)
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 24  

1415   2              {
1416   3                  #if(!CY_PSOC5A)
1417   3      
1418   3                      /* Read XERR bit to clear it */
1419   3                      (void) CY_CLK_XMHZ_CSR_REG;
1420   3      
1421   3                  #endif  /* (!CY_PSOC5A) */
1422   3      
1423   3      
1424   3                  /* Wait for a millisecond - 4 x 250 us */
1425   3                  for(count = 4u; count > 0u; count--)
1426   3                  {
1427   4                      while(!(CY_PM_FTW_INT == CyPmReadStatus(CY_PM_FTW_INT)))
1428   4                      {
1429   5                          /* Wait for the FTW interrupt event */
1430   5                      }
1431   4                  }
1432   3      
1433   3      
1434   3                  #if(!CY_PSOC5A)
1435   3      
1436   3                      /*******************************************************************
1437   3                      * High output indicates oscillator failure.
1438   3                      * Only can be used after start-up interval (1 ms) is completed.
1439   3                      *******************************************************************/
1440   3                      if(0u == (CY_CLK_XMHZ_CSR_REG & CY_CLK_XMHZ_CSR_XERR))
1441   3                      {
1442   4                          status = CYRET_SUCCESS;
1443   4                          break;
1444   4                      }
1445   3      
1446   3                  #endif  /* (!CY_PSOC5A) */
1447   3              }
1448   2      
1449   2      
1450   2              /* Restore 100 KHz ILO, FTW interval, enable and interrupt enable */
1451   2              if(0u == (iloEnableState & ILO_CONTROL_100KHZ_ON))
1452   2              {
1453   3                  CyILO_Stop100K();
1454   3              }
1455   2              CY_PM_TW_CFG0_REG = pmTwCfg0Tmp;
1456   2              CY_PM_TW_CFG2_REG = pmTwCfg2Tmp;
1457   2          }
1458   1      
1459   1          return(status);
1460   1      }
1461          
1462          
1463          /*******************************************************************************
1464          * Function Name: CyXTAL_Stop
1465          ********************************************************************************
1466          *
1467          * Summary:
1468          *  Disables the megahertz crystal oscillator.
1469          *
1470          * Parameters:
1471          *  None
1472          *
1473          * Return:
1474          *  None
1475          *
1476          *******************************************************************************/
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 25  

1477          void CyXTAL_Stop(void) 
1478          {
1479   1          /* Disable the the oscillator. */
1480   1          FASTCLK_XMHZ_CSR &= ((uint8)(~XMHZ_CONTROL_ENABLE));
1481   1      }
1482          
1483          
1484          #if(!CY_PSOC5A)
1485          
1486              /*******************************************************************************
1487              * Function Name: CyXTAL_EnableErrStatus
1488              ********************************************************************************
1489              *
1490              * Summary:
1491              *  Enables the generation of the XERR status bit for the megahertz crystal.
1492              *  This function is not available for PSoC5.
1493              *
1494              * Parameters:
1495              *  None
1496              *
1497              * Return:
1498              *  None
1499              *
1500              *******************************************************************************/
1501              void CyXTAL_EnableErrStatus(void) 
1502              {
1503   1              /* If oscillator has insufficient amplitude, XERR bit will be high. */
1504   1              CY_CLK_XMHZ_CSR_REG &= ((uint8)(~CY_CLK_XMHZ_CSR_XFB));
1505   1          }
1506          
1507          
1508              /*******************************************************************************
1509              * Function Name: CyXTAL_DisableErrStatus
1510              ********************************************************************************
1511              *
1512              * Summary:
1513              *  Disables the generation of the XERR status bit for the megahertz crystal.
1514              *  This function is not available for PSoC5.
1515              *
1516              * Parameters:
1517              *  None
1518              *
1519              * Return:
1520              *  None
1521              *
1522              *******************************************************************************/
1523              void CyXTAL_DisableErrStatus(void) 
1524              {
1525   1              /* If oscillator has insufficient amplitude, XERR bit will be high. */
1526   1              CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_XFB;
1527   1          }
1528          
1529          
1530              /*******************************************************************************
1531              * Function Name: CyXTAL_ReadStatus
1532              ********************************************************************************
1533              *
1534              * Summary:
1535              *  Reads the XERR status bit for the megahertz crystal. This status bit is a
1536              *  sticky clear on read value. This function is not available for PSoC5.
1537              *
1538              * Parameters:
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 26  

1539              *  None
1540              *
1541              * Return:
1542              *   Status
1543              *    0: No error
1544              *    1: Error
1545              *
1546              *******************************************************************************/
1547              uint8 CyXTAL_ReadStatus(void) 
1548              {
1549   1              /***************************************************************************
1550   1              * High output indicates oscillator failure. Only use this after start-up
1551   1              * interval is completed. This can be used for status and failure recovery.
1552   1              ***************************************************************************/
1553   1              return((0u != (CY_CLK_XMHZ_CSR_REG & CY_CLK_XMHZ_CSR_XERR)) ? 1u : 0u);
1554   1          }
1555          
1556          
1557              /*******************************************************************************
1558              * Function Name: CyXTAL_EnableFaultRecovery
1559              ********************************************************************************
1560              *
1561              * Summary:
1562              *  Enables the fault recovery circuit which will switch to the IMO in the case
1563              *  of a fault in the megahertz crystal circuit. The crystal must be up and
1564              *  running with the XERR bit at 0, before calling this function to prevent
1565              *  immediate fault switchover. This function is not available for PSoC5.
1566              *
1567              * Parameters:
1568              *  None
1569              *
1570              * Return:
1571              *  None
1572              *
1573              *******************************************************************************/
1574              void CyXTAL_EnableFaultRecovery(void) 
1575              {
1576   1              CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_XPROT;
1577   1          }
1578          
1579          
1580              /*******************************************************************************
1581              * Function Name: CyXTAL_DisableFaultRecovery
1582              ********************************************************************************
1583              *
1584              * Summary:
1585              *  Disables the fault recovery circuit which will switch to the IMO in the case
1586              *  of a fault in the megahertz crystal circuit. This function is not available
1587              *  for PSoC5.
1588              *
1589              * Parameters:
1590              *  None
1591              *
1592              * Return:
1593              *  None
1594              *
1595              *******************************************************************************/
1596              void CyXTAL_DisableFaultRecovery(void) 
1597              {
1598   1              CY_CLK_XMHZ_CSR_REG &= ((uint8)(~CY_CLK_XMHZ_CSR_XPROT));
1599   1          }
1600          
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 27  

1601          #endif  /* (!CY_PSOC5A) */
1602          
1603          /*******************************************************************************
1604          * Function Name: CyXTAL_SetStartup
1605          ********************************************************************************
1606          *
1607          * Summary:
1608          *  Sets the startup settings for the crystal. Logic model outputs a frequency
1609          *  (setting + 4) MHz when enabled.
1610          *
1611          *  This is artificial as the actual frequency is determined by an attached
1612          *  external crystal.
1613          *
1614          * Parameters:
1615          *  setting: Valid range [0-31].
1616          *   Value is dependent on the frequency and quality of the crystal being used.
1617          *   Refer to the device TRM and datasheet for more information.
1618          *
1619          * Return:
1620          *  None
1621          *
1622          *******************************************************************************/
1623          void CyXTAL_SetStartup(uint8 setting) 
1624          {
1625   1          CY_CLK_XMHZ_CFG0_REG = (CY_CLK_XMHZ_CFG0_REG & ((uint8)(~CY_CLK_XMHZ_CFG0_XCFG_MASK))) |
1626   1                                 (setting & CY_CLK_XMHZ_CFG0_XCFG_MASK);
1627   1      }
1628          
1629          
1630          #if(CY_PSOC3 || CY_PSOC5LP)
1631              /*******************************************************************************
1632              * Function Name: CyXTAL_SetFbVoltage
1633              ********************************************************************************
1634              *
1635              * Summary:
1636              *  Sets the feedback reference voltage to use for the crystal circuit.
1637              *  This function is only available for PSoC3 and PSoC 5LP.
1638              *
1639              * Parameters:
1640              *  setting: Valid range [0-15].
1641              *  Refer to the device TRM and datasheet for more information.
1642              *
1643              * Return:
1644              *  None
1645              *
1646              *******************************************************************************/
1647              void CyXTAL_SetFbVoltage(uint8 setting) 
1648              {
1649   1              CY_CLK_XMHZ_CFG1_REG = ((CY_CLK_XMHZ_CFG1_REG & ((uint8)(~CY_CLK_XMHZ_CFG1_VREF_FB_MASK))) |
1650   1                                      (setting & CY_CLK_XMHZ_CFG1_VREF_FB_MASK));
1651   1          }
1652          
1653          
1654              /*******************************************************************************
1655              * Function Name: CyXTAL_SetWdVoltage
1656              ********************************************************************************
1657              *
1658              * Summary:
1659              *  Sets the reference voltage used by the watchdog to detect a failure in the
1660              *  crystal circuit. This function is only available for PSoC3 and PSoC 5LP.
1661              *
1662              * Parameters:
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 28  

1663              *  setting: Valid range [0-7].
1664              *  Refer to the device TRM and datasheet for more information.
1665              *
1666              * Return:
1667              *  None
1668              *
1669              *******************************************************************************/
1670              void CyXTAL_SetWdVoltage(uint8 setting) 
1671              {
1672   1              CY_CLK_XMHZ_CFG1_REG = ((CY_CLK_XMHZ_CFG1_REG & ((uint8)(~CY_CLK_XMHZ_CFG1_VREF_WD_MASK))) |
1673   1                                      (((uint8)(setting << 4u)) & CY_CLK_XMHZ_CFG1_VREF_WD_MASK));
1674   1          }
1675          
1676          #endif /* (CY_PSOC3 || CY_PSOC5LP) */
1677          
1678          
1679          /*******************************************************************************
1680          * Function Name: CyHalt
1681          ********************************************************************************
1682          *
1683          * Summary:
1684          *  Halts the CPU.
1685          *
1686          * Parameters:
1687          *  uint8 reason: Value to be used during debugging.
1688          *
1689          * Return:
1690          *  None
1691          *
1692          *******************************************************************************/
1693          void CyHalt(uint8 reason) CYREENTRANT
1694          {
1695   1          if(0u != reason)
1696   1          {
1697   2              /* To remove unreferenced local variable warning */
1698   2          }
1699   1      
1700   1          #if defined (__ARMCC_VERSION)
                      __breakpoint(0x0);
                  #elif defined(__GNUC__)
                      __asm("    bkpt    1");
                  #elif defined(__C51__)
1705   1              CYDEV_HALT_CPU;
1706   1          #endif  /* (__ARMCC_VERSION) */
1707   1      }
1708          
1709          
1710          /*******************************************************************************
1711          * Function Name: CySoftwareReset
1712          ********************************************************************************
1713          *
1714          * Summary:
1715          *  Forces a software reset of the device.
1716          *
1717          * Parameters:
1718          *  None
1719          *
1720          * Return:
1721          *  None
1722          *
1723          *******************************************************************************/
1724          void CySoftwareReset(void) 
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 29  

1725          {
1726   1          /* Perform software reset */
1727   1          *RESET_CR2 = 0x1u;
1728   1      }
1729          
1730          
1731          /*******************************************************************************
1732          * Function Name: CyDelay
1733          ********************************************************************************
1734          *
1735          * Summary:
1736          *  Blocks for milliseconds.
1737          *
1738          *  Note:
1739          *  CyDelay has been implemented with the instruction cache assumed enabled. When
1740          *  instruction cache is disabled on PSoC5, CyDelay will be two times larger. For
1741          *  example, with instruction cache disabled CyDelay(100) would result in about
1742          *  200 ms delay instead of 100 ms.
1743          *
1744          * Parameters:
1745          *  milliseconds: number of milliseconds to delay.
1746          *
1747          * Return:
1748          *   None
1749          *
1750          *******************************************************************************/
1751          void CyDelay(uint32 milliseconds) CYREENTRANT
1752          {
1753   1          while (milliseconds > 32768u)
1754   1          {
1755   2              /***********************************************************************
1756   2              * This loop prevents overflow.At 100MHz, milliseconds * delay_freq_khz
1757   2              * overflows at about 42 seconds.
1758   2              ***********************************************************************/
1759   2              CyDelayCycles(cydelay_32k_ms);
1760   2              milliseconds = ((uint32)(milliseconds - 32768u));
1761   2          }
1762   1      
1763   1          CyDelayCycles(milliseconds * cydelay_freq_khz);
1764   1      }
1765          
1766          
1767          #if(!CY_PSOC3)
              
                  /* For PSoC3 devices function is defined in CyBootAsmKeil.a51 file */
              
                  /*******************************************************************************
                  * Function Name: CyDelayUs
                  ********************************************************************************
                  *
                  * Summary:
                  *  Blocks for microseconds.
                  *
                  *  Note:
                  *   CyDelay has been implemented with the instruction cache assumed enabled.
                  *   When instruction cache is disabled on PSoC5, CyDelayUs will be two times
                  *   larger. Ex: With instruction cache disabled CyDelayUs(100) would result
                  *   in about 200us delay instead of 100us.
                  *
                  * Parameters:
                  *  uint16 microseconds: number of microseconds to delay.
                  *
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 30  

                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  CyDelayUS has been implemented with the instruction cache assumed enabled.
                  *  When instruction cache is disabled on PSoC 5, CyDelayUs will be two times
                  *  larger. For example, with instruction cache disabled CyDelayUs(100) would
                  *  result in about 200 us delay instead of 100 us.
                  *
                  *  If the bus clock frequency is a small non-integer number, the actual delay
                  *  can be up to twice as long as the nominal value. The actual delay cannot be
                  *  shorter than the nominal one.
                  *******************************************************************************/
                  void CyDelayUs(uint16 microseconds) CYREENTRANT
                  {
                      CyDelayCycles((uint32)microseconds * cydelay_freq_mhz);
                  }
              
              #endif  /* (!CY_PSOC3) */
1806          
1807          
1808          /*******************************************************************************
1809          * Function Name: CyDelayFreq
1810          ********************************************************************************
1811          *
1812          * Summary:
1813          *  Sets clock frequency for CyDelay.
1814          *
1815          * Parameters:
1816          *  freq: Frequency of bus clock in Hertz.
1817          *
1818          * Return:
1819          *  None
1820          *
1821          *******************************************************************************/
1822          void CyDelayFreq(uint32 freq) CYREENTRANT
1823          {
1824   1          if (freq != 0u)
1825   1          {
1826   2              cydelay_freq_hz = freq;
1827   2          }
1828   1          else
1829   1          {
1830   2              cydelay_freq_hz = BCLK__BUS_CLK__HZ;
1831   2          }
1832   1      
1833   1          cydelay_freq_mhz = (uint8)((cydelay_freq_hz + 999999u) / 1000000u);
1834   1          cydelay_freq_khz = (cydelay_freq_hz + 999u) / 1000u;
1835   1          cydelay_32k_ms   = 32768u * cydelay_freq_khz;
1836   1      }
1837          
1838          
1839          /*******************************************************************************
1840          * Function Name: CyWdtStart
1841          ********************************************************************************
1842          *
1843          * Summary:
1844          *  Enables the watchdog timer.
1845          *
1846          *  The timer is configured for the specified count interval, the central
1847          *  timewheel is cleared, the setting for low power mode is configured and the
1848          *  watchdog timer is enabled.
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 31  

1849          *
1850          *  Once enabled the watchdog cannot be disabled. The watchdog counts each time
1851          *  the Central Time Wheel (CTW) reaches the period specified. The watchdog must
1852          *  be cleared using the CyWdtClear() function before three ticks of the watchdog
1853          *  timer occur. The CTW is free running, so this will occur after between 2 and
1854          *  3 timer periods elapse.
1855          *
1856          *  PSoC5: The watchdog timer should not be used during sleep modes. Since the
1857          *  WDT cannot be disabled after it is enabled, the WDT timeout period can be
1858          *  set to be greater than the sleep wakeup period, then feed the dog on each
1859          *  wakeup from Sleep.
1860          *
1861          * Parameters:
1862          *  ticks: One of the four available timer periods. Once WDT enabled, the
1863             interval cannot be changed.
1864          *         CYWDT_2_TICKS     -     4 - 6     ms
1865          *         CYWDT_16_TICKS    -    32 - 48    ms
1866          *         CYWDT_128_TICKS   -   256 - 384   ms
1867          *         CYWDT_1024_TICKS  - 2.048 - 3.072 s
1868          *
1869          *  lpMode: Low power mode configuration. This parameter is ignored for PSoC 5.
1870          *          The WDT always acts as if CYWDT_LPMODE_NOCHANGE is passed.
1871          *
1872          *          CYWDT_LPMODE_NOCHANGE - No Change
1873          *          CYWDT_LPMODE_MAXINTER - Switch to longest timer mode during low power
1874          *                                 mode
1875          *          CYWDT_LPMODE_DISABLED - Disable WDT during low power mode
1876          *
1877          * Return:
1878          *  None
1879          *
1880          * Side Effects:
1881          *  PSoC5: The ILO 1 KHz must be enabled for proper WDT operation. Stopping the
1882          *  ILO 1 kHz could break the active WDT functionality.
1883          *
1884          *******************************************************************************/
1885          void CyWdtStart(uint8 ticks, uint8 lpMode) 
1886          {
1887   1          #if(CY_PSOC5A)
                      CyILO_Start1K();
                  #endif  /* (CY_PSOC5A) */
1890   1      
1891   1          /* Set WDT interval */
1892   1          CY_WDT_CFG_REG = (CY_WDT_CFG_REG & ((uint8)(~CY_WDT_CFG_INTERVAL_MASK))) | (ticks & CY_WDT_CFG_INTERVA
             -L_MASK);
1893   1      
1894   1          /* Reset CTW to ensure that first watchdog period is full */
1895   1          CY_WDT_CFG_REG |= CY_WDT_CFG_CTW_RESET;
1896   1          CY_WDT_CFG_REG &= ((uint8)(~CY_WDT_CFG_CTW_RESET));
1897   1      
1898   1          #if(!CY_PSOC5A)
1899   1      
1900   1              /* Setting the low power mode */
1901   1              CY_WDT_CFG_REG = (((uint8)(lpMode << CY_WDT_CFG_LPMODE_SHIFT)) & CY_WDT_CFG_LPMODE_MASK) |
1902   1                                (CY_WDT_CFG_REG & ((uint8)(~CY_WDT_CFG_LPMODE_MASK)));
1903   1          #else
              
                      if(0u != lpMode)
                      {
                          /* To remove unreferenced local variable warning */
                      }
              
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 32  

                  #endif  /* (!CY_PSOC5A) */
1911   1      
1912   1          /* Enables the watchdog reset */
1913   1          CY_WDT_CFG_REG |= CY_WDT_CFG_WDR_EN;
1914   1      }
1915          
1916          
1917          /*******************************************************************************
1918          * Function Name: CyWdtClear
1919          ********************************************************************************
1920          *
1921          * Summary:
1922          *  Clears (feeds) the watchdog timer.
1923          *
1924          * Parameters:
1925          *  None
1926          *
1927          * Return:
1928          *  None
1929          *
1930          *******************************************************************************/
1931          void CyWdtClear(void) 
1932          {
1933   1          #if(CY_PSOC5A)
              
                      /* PSoC5 ES1 watchdog time clear requires workaround */
                      uint8 wdtCfg = CY_WDT_CFG_REG;
                      CY_WDT_CR_REG  = CY_WDT_CR_FEED;
                      CY_WDT_CFG_REG = CY_WDT_CFG_CLEAR_ALL;
                      CY_WDT_CFG_REG = wdtCfg;
              
                  #else
1942   1      
1943   1              CY_WDT_CR_REG = CY_WDT_CR_FEED;
1944   1      
1945   1          #endif  /* (CY_PSOC5A) */
1946   1      }
1947          
1948          
1949          
1950          /*******************************************************************************
1951          * Function Name: CyVdLvDigitEnable
1952          ********************************************************************************
1953          *
1954          * Summary:
1955          *  Enables the digital low voltage monitors to generate interrupt on Vddd
1956          *   archives specified threshold and optionally resets device.
1957          *
1958          * Parameters:
1959          *  reset: Option to reset device at a specified Vddd threshold:
1960          *           0 - Device is not reset.
1961          *           1 - Device is reset.
1962          *         This option is applicable for PSoC 3/PSoC 5LP devices only.
1963          *
1964          *  threshold: Sets the trip level for the voltage monitor.
1965          *  Values from 1.70 V to 5.45 V(for PSoC 3/PSoC 5LP) and from 2.45 V to 5.45 V
1966          *  (for PSoC 5TM) are accepted with the approximately 250 mV interval.
1967          *
1968          * Return:
1969          *  None
1970          *
1971          *******************************************************************************/
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 33  

1972          void CyVdLvDigitEnable(uint8 reset, uint8 threshold) 
1973          {
1974   1          *CY_INT_CLEAR_PTR = 0x01u;
1975   1      
1976   1          #if(!CY_PSOC5A)
1977   1              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1978   1          #endif /*(!CY_PSOC5A)*/
1979   1      
1980   1          CY_VD_LVI_TRIP_REG = (threshold & CY_VD_LVI_TRIP_LVID_MASK) |
1981   1                                  (CY_VD_LVI_TRIP_REG & ((uint8)(~CY_VD_LVI_TRIP_LVID_MASK)));
1982   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_LVID_EN;
1983   1      
1984   1          /* Timeout to eliminate glitches on the LVI/HVI when enabling */
1985   1          CyDelayUs(1u);
1986   1      
1987   1              (void)CY_VD_PERSISTENT_STATUS_REG;
1988   1      
1989   1          #if(!CY_PSOC5A)
1990   1              if(0u != reset)
1991   1              {
1992   2                  CY_VD_PRES_CONTROL_REG |= CY_VD_PRESD_EN;
1993   2              }
1994   1              else
1995   1              {
1996   2                  CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1997   2              }
1998   1          #else
              
                      if(0u != reset)
                      {
                          /* To remove unreferenced local variable warning */
                      }
              
                  #endif /*(!CY_PSOC5A)*/
2006   1      
2007   1          *CY_INT_CLR_PEND_PTR = 0x01u;
2008   1          *CY_INT_ENABLE_PTR   = 0x01u;
2009   1      }
2010          
2011          
2012          /*******************************************************************************
2013          * Function Name: CyVdLvAnalogEnable
2014          ********************************************************************************
2015          *
2016          * Summary:
2017          *  Enables the analog low voltage monitors to generate interrupt on Vdda
2018          *   archives specified threshold and optionally resets device.
2019          *
2020          * Parameters:
2021          *  reset: Option to reset device at a specified Vdda threshold:
2022          *           0 - Device is not reset.
2023          *           1 - Device is reset.
2024          *         This option is applicable for PSoC 3/PSoC 5LP devices only.
2025          *
2026          *  threshold: Sets the trip level for the voltage monitor.
2027          *  Values from 1.70 V to 5.45 V(for PSoC 3/PSoC 5LP) and from 2.45 V to 5.45 V
2028          *  (for PSoC 5TM) are accepted with the approximately 250 mV interval.
2029          *
2030          * Return:
2031          *  None
2032          *
2033          *******************************************************************************/
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 34  

2034          void CyVdLvAnalogEnable(uint8 reset, uint8 threshold) 
2035          {
2036   1          *CY_INT_CLEAR_PTR = 0x01u;
2037   1      
2038   1          #if(!CY_PSOC5A)
2039   1              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2040   1          #endif /*(!CY_PSOC5A)*/
2041   1      
2042   1          CY_VD_LVI_TRIP_REG = ((uint8)(threshold << 4u)) | (CY_VD_LVI_TRIP_REG & 0x0Fu);
2043   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_LVIA_EN;
2044   1      
2045   1          /* Timeout to eliminate glitches on the LVI/HVI when enabling */
2046   1          CyDelayUs(1u);
2047   1      
2048   1              (void)CY_VD_PERSISTENT_STATUS_REG;
2049   1      
2050   1          #if(!CY_PSOC5A)
2051   1              if(0u != reset)
2052   1              {
2053   2                  CY_VD_PRES_CONTROL_REG |= CY_VD_PRESA_EN;
2054   2              }
2055   1              else
2056   1              {
2057   2                  CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2058   2              }
2059   1          #else
              
                      if(0u != reset)
                      {
                          /* To remove unreferenced local variable warning */
                      }
              
                  #endif /*(!CY_PSOC5A)*/
2067   1      
2068   1          *CY_INT_CLR_PEND_PTR = 0x01u;
2069   1          *CY_INT_ENABLE_PTR   = 0x01u;
2070   1      }
2071          
2072          
2073          /*******************************************************************************
2074          * Function Name: CyVdLvDigitDisable
2075          ********************************************************************************
2076          *
2077          * Summary:
2078          *  Disables the digital low voltage monitor (interrupt and device reset are
2079          *  disabled).
2080          *
2081          * Parameters:
2082          *  None
2083          *
2084          * Return:
2085          *  None
2086          *
2087          *******************************************************************************/
2088          void CyVdLvDigitDisable(void) 
2089          {
2090   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_LVID_EN));
2091   1      
2092   1          #if(!CY_PSOC5A)
2093   1              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
2094   1          #endif /*(!CY_PSOC5A)*/
2095   1      
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 35  

2096   1          while(0u != (CY_VD_PERSISTENT_STATUS_REG & 0x07u))
2097   1          {
2098   2      
2099   2          }
2100   1      }
2101          
2102          
2103          /*******************************************************************************
2104          * Function Name: CyVdLvAnalogDisable
2105          ********************************************************************************
2106          *
2107          * Summary:
2108          *  Disables the analog low voltage monitor
2109          *  (interrupt and device reset are disabled).
2110          *
2111          * Parameters:
2112          *  None
2113          *
2114          * Return:
2115          *  None
2116          *
2117          *******************************************************************************/
2118          void CyVdLvAnalogDisable(void) 
2119          {
2120   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_LVIA_EN));
2121   1      
2122   1          #if(!CY_PSOC5A)
2123   1              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2124   1          #endif /*(!CY_PSOC5A)*/
2125   1      
2126   1          while(0u != (CY_VD_PERSISTENT_STATUS_REG & 0x07u))
2127   1          {
2128   2      
2129   2          }
2130   1      }
2131          
2132          
2133          /*******************************************************************************
2134          * Function Name: CyVdHvAnalogEnable
2135          ********************************************************************************
2136          *
2137          * Summary:
2138          *  Enables the analog high voltage monitors to generate interrupt on
2139          *  Vdda archives 5.75 V threshold and optionally resets device.
2140          *
2141          * Parameters:
2142          *  None
2143          *
2144          * Return:
2145          *  None
2146          *
2147          *******************************************************************************/
2148          void CyVdHvAnalogEnable(void) 
2149          {
2150   1          *CY_INT_CLEAR_PTR = 0x01u;
2151   1      
2152   1          #if(!CY_PSOC5A)
2153   1              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2154   1          #endif /*(!CY_PSOC5A)*/
2155   1      
2156   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_HVIA_EN;
2157   1      
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 36  

2158   1          /* Timeout to eliminate glitches on the LVI/HVI when enabling */
2159   1          CyDelayUs(1u);
2160   1      
2161   1              (void) CY_VD_PERSISTENT_STATUS_REG;
2162   1      
2163   1          *CY_INT_CLR_PEND_PTR = 0x01u;
2164   1          *CY_INT_ENABLE_PTR   = 0x01u;
2165   1      }
2166          
2167          
2168          /*******************************************************************************
2169          * Function Name: CyVdHvAnalogDisable
2170          ********************************************************************************
2171          *
2172          * Summary:
2173          *  Disables the analog low voltage monitor
2174          *  (interrupt and device reset are disabled).
2175          *
2176          * Parameters:
2177          *  None
2178          *
2179          * Return:
2180          *  None
2181          *
2182          *******************************************************************************/
2183          void CyVdHvAnalogDisable(void) 
2184          {
2185   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_HVIA_EN));
2186   1      }
2187          
2188          
2189          /*******************************************************************************
2190          * Function Name: CyVdStickyStatus
2191          ********************************************************************************
2192          *
2193          * Summary:
2194          *  Manages the Reset and Voltage Detection Status Register 0.
2195          *  This register has the interrupt status for the HVIA, LVID and LVIA.
2196          *  This hardware register clears on read.
2197          *
2198          * Parameters:
2199          *  mask: Bits in the shadow register to clear.
2200          *       Value        Define                Bit To Clear
2201          *       0x01         CY_VD_LVID            LVID
2202          *       0x02         CY_VD_LVIA            LVIA
2203          *       0x04         CY_VD_HVIA            HVIA
2204          *
2205          * Return:
2206          *  Status.  Same enumerated bit values as used for the mask parameter.
2207          *
2208          *******************************************************************************/
2209          uint8 CyVdStickyStatus(uint8 mask) 
2210          {
2211   1          uint8 status;
2212   1      
2213   1          status = CY_VD_PERSISTENT_STATUS_REG;
2214   1          CY_VD_PERSISTENT_STATUS_REG &= ((uint8)(~mask));
2215   1      
2216   1          return(status);
2217   1      }
2218          
2219          
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 37  

2220          /*******************************************************************************
2221          * Function Name: CyVdRealTimeStatus
2222          ********************************************************************************
2223          *
2224          * Summary:
2225          *  Returns the real time voltage detection status.
2226          *
2227          * Parameters:
2228          *  None
2229          *
2230          * Return:
2231          *  Status. Same enumerated bit values as used for the mask parameter.
2232          *
2233          *******************************************************************************/
2234          uint8 CyVdRealTimeStatus(void) 
2235          {
2236   1          uint8 interruptState;
2237   1          uint8 vdFlagsState;
2238   1      
2239   1          interruptState = CyEnterCriticalSection();
2240   1          vdFlagsState = CY_VD_RT_STATUS_REG;
2241   1          CyExitCriticalSection(interruptState);
2242   1      
2243   1          return(vdFlagsState);
2244   1      }
2245          
2246          
2247          /*******************************************************************************
2248          * Function Name: CyDisableInts
2249          ********************************************************************************
2250          *
2251          * Summary:
2252          *  Disables the interrupt enable for each interrupt.
2253          *
2254          * Parameters:
2255          *  None
2256          *
2257          * Return:
2258          *  32 bit mask of previously enabled interrupts.
2259          *
2260          *******************************************************************************/
2261          uint32 CyDisableInts(void) 
2262          {
2263   1          uint32 intState;
2264   1          uint8 interruptState;
2265   1      
2266   1          interruptState = CyEnterCriticalSection();
2267   1      
2268   1          #if(CY_PSOC3)
2269   1      
2270   1              /* Get the current interrupt state. */
2271   1              intState  = ((uint32) CY_GET_REG8(CY_INT_CLR_EN0_PTR));
2272   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN1_PTR)) << 8u));
2273   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN2_PTR)) << 16u));
2274   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN3_PTR)) << 24u));
2275   1      
2276   1      
2277   1              /* Disable all of the interrupts. */
2278   1              CY_SET_REG8(CY_INT_CLR_EN0_PTR, 0xFFu);
2279   1              CY_SET_REG8(CY_INT_CLR_EN1_PTR, 0xFFu);
2280   1              CY_SET_REG8(CY_INT_CLR_EN2_PTR, 0xFFu);
2281   1              CY_SET_REG8(CY_INT_CLR_EN3_PTR, 0xFFu);
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 38  

2282   1      
2283   1          #else
              
                      /* Get the current interrupt state. */
                      intState = CY_GET_REG32(CY_INT_CLEAR_PTR);
              
                      /* Disable all of the interrupts. */
                      CY_SET_REG32(CY_INT_CLEAR_PTR, 0xFFFFFFFFu);
              
                  #endif /* (CY_PSOC3) */
2292   1      
2293   1          CyExitCriticalSection(interruptState);
2294   1      
2295   1          return (intState);
2296   1      }
2297          
2298          
2299          /*******************************************************************************
2300          * Function Name: CyEnableInts
2301          ********************************************************************************
2302          *
2303          * Summary:
2304          *  Enables interrupts to a given state.
2305          *
2306          * Parameters:
2307          *  uint32 mask: 32 bit mask of interrupts to enable.
2308          *
2309          * Return:
2310          *  None
2311          *
2312          *******************************************************************************/
2313          void CyEnableInts(uint32 mask) 
2314          {
2315   1      
2316   1          uint8 interruptState;
2317   1      
2318   1          interruptState = CyEnterCriticalSection();
2319   1      
2320   1          #if(CY_PSOC3)
2321   1      
2322   1              /* Set interrupts as enabled. */
2323   1              CY_SET_REG8(CY_INT_SET_EN3_PTR, ((uint8) (mask >> 24u)));
2324   1              CY_SET_REG8(CY_INT_SET_EN2_PTR, ((uint8) (mask >> 16u)));
2325   1              CY_SET_REG8(CY_INT_SET_EN1_PTR, ((uint8) (mask >> 8u )));
2326   1              CY_SET_REG8(CY_INT_SET_EN0_PTR, ((uint8) (mask )));
2327   1      
2328   1          #else
              
                      CY_SET_REG32(CY_INT_ENABLE_PTR, mask);
              
                  #endif /* (CY_PSOC3) */
2333   1      
2334   1          CyExitCriticalSection(interruptState);
2335   1      
2336   1      }
2337          
2338          #if(CY_PSOC5)
              
                  /*******************************************************************************
                  * Function Name: CyFlushCache
                  ********************************************************************************
                  * Summary:
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 39  

                  *  Flushes the PSoC 5/5LP cache by invalidating all entries.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CyFlushCache(void)
                  {
                      uint8 interruptState;
              
                      /* Save current global interrupt enable and disable it */
                      interruptState = CyEnterCriticalSection();
              
                      /* Fill instruction prefectch unit to insure data integrity */
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
              
                      /* All entries in the cache are invalidated on the next clock cycle. */
                      CY_CACHE_CONTROL_REG |= CY_CACHE_CONTROL_FLUSH;
              
              
                      /***********************************************************************
                      * The prefetch unit could/would be filled with the instructions that
                      * succeed the flush. Since a flush is desired then theoretically those
                      * instructions might be considered stale/invalid.
                      ***********************************************************************/
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
              
                      /* Restore global interrupt enable state */
                      CyExitCriticalSection(interruptState);
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 40  

                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetSysVector
                  ********************************************************************************
                  * Summary:
                  *  Sets the interrupt vector of the specified system interrupt number. System
                  *  interrupts are present only for the ARM platform. These interrupts are for
                  *  SysTick, PendSV and others.
                  *
                  * Parameters:
                  *  number: Interrupt number, valid range [0-15].
                     address: Pointer to an interrupt service routine.
                  *
                  * Return:
                  *   The old ISR vector at this location.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntSetSysVector(uint8 number, cyisraddress address)
                  {
                      cyisraddress oldIsr;
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
              
                      CYASSERT(number <= CY_INT_SYS_NUMBER_MAX);
              
                      /* Save old Interrupt service routine. */
                      oldIsr = ramVectorTable[number & CY_INT_SYS_NUMBER_MASK];
              
                      /* Set new Interrupt service routine. */
                      ramVectorTable[number & CY_INT_SYS_NUMBER_MASK] = address;
              
                      return (oldIsr);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetSysVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the interrupt vector of the specified system interrupt number. System
                  *  interrupts are present only for the ARM platform. These interrupts are for
                  *  SysTick, PendSV and others.
                  *
                  * Parameters:
                  *   number: The interrupt number, valid range [0-15].
                  *
                  * Return:
                  *   Address of the ISR in the interrupt vector table.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntGetSysVector(uint8 number)
                  {
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
                      CYASSERT(number <= CY_INT_SYS_NUMBER_MAX);
              
                      return ramVectorTable[number & CY_INT_SYS_NUMBER_MASK];
                  }
              
              
                  /*******************************************************************************
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 41  

                  * Function Name: CyIntSetVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the interrupt vector of the specified interrupt number.
                  *
                  * Parameters:
                  *  number: Valid range [0-31].  Interrupt number
                  *  address: Pointer to an interrupt service routine
                  *
                  * Return:
                  *   Previous interrupt vector value.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntSetVector(uint8 number, cyisraddress address)
                  {
                      cyisraddress oldIsr;
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      /* Save old Interrupt service routine. */
                      oldIsr = ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)];
              
                      /* Set new Interrupt service routine. */
                      ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)] = address;
              
                      return (oldIsr);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the interrupt vector of the specified interrupt number.
                  *
                  * Parameters:
                  *  number: Valid range [0-31].  Interrupt number
                  *
                  * Return:
                  *  Address of the ISR in the interrupt vector table.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntGetVector(uint8 number)
                  {
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      return (ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)]);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetPriority
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the Priority of the Interrupt.
                  *
                  * Parameters:
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 42  

                  *  priority: Priority of the interrupt. 0 - 7, 0 being the highest.
                  *  number: The number of the interrupt, 0 - 31.
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CyIntSetPriority(uint8 number, uint8 priority)
                  {
                      CYASSERT(priority <= CY_INT_PRIORITY_MAX);
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
                      CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] = (priority & CY_INT_PRIORITY_MASK)<< 5;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetPriority
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the Priority of the Interrupt.
                  *
                  * Parameters:
                  *  number: The number of the interrupt, 0 - 31.
                  *
                  * Return:
                  *  Priority of the interrupt. 0 - 7, 0 being the highest.
                  *
                  *******************************************************************************/
                  uint8 CyIntGetPriority(uint8 number)
                  {
                      uint8 priority;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      priority = CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] >> 5;
              
                      return (priority);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetState
                  ********************************************************************************
                  *
                  * Summary:
                  *   Gets the enable state of the specified interrupt number.
                  *
                  * Parameters:
                  *   number: Valid range [0-31].  Interrupt number.
                  *
                  * Return:
                  *   Enable status: 1 if enabled, 0 if disabled
                  *
                  *******************************************************************************/
                  uint8 CyIntGetState(uint8 number)
                  {
                      reg32 * stateReg;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      /* Get a pointer to the Interrupt enable register. */
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 43  

                      stateReg = CY_INT_ENABLE_PTR;
              
                      /* Get the state of the interrupt. */
                      return (0u != (*stateReg & (((uint32) 1u) << (0x1Fu & number)))) ? ((uint8)(1u)) : ((uint8)(0u));
                  }
              
              
              #else   /* PSoC3 */
2600          
2601          
2602              /*******************************************************************************
2603              * Function Name: CyIntSetVector
2604              ********************************************************************************
2605              *
2606              * Summary:
2607              *  Sets the interrupt vector of the specified interrupt number.
2608              *
2609              * Parameters:
2610              *  number:  Valid range [0-31].  Interrupt number
2611              *  address: Pointer to an interrupt service routine
2612              *
2613              * Return:
2614              *  Previous interrupt vector value.
2615              *
2616              *******************************************************************************/
2617              cyisraddress CyIntSetVector(uint8 number, cyisraddress address) 
2618              {
2619   1              cyisraddress oldIsr;
2620   1      
2621   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2622   1      
2623   1              /* Save old Interrupt service routine. */
2624   1              oldIsr = (cyisraddress) \
2625   1                          CY_GET_REG16(&CY_INT_VECT_TABLE[number & CY_INT_NUMBER_MASK]);
2626   1      
2627   1              /* Set new Interrupt service routine. */
2628   1              CY_SET_REG16(&CY_INT_VECT_TABLE[number], (uint16) address);
2629   1      
2630   1              return (oldIsr);
2631   1          }
2632          
2633          
2634              /*******************************************************************************
2635              * Function Name: CyIntGetVector
2636              ********************************************************************************
2637              *
2638              * Summary:
2639              *  Gets the interrupt vector of the specified interrupt number.
2640              *
2641              * Parameters:
2642              *  number: Valid range [0-31].  Interrupt number
2643              *
2644              * Return:
2645              *  Address of the ISR in the interrupt vector table.
2646              *
2647              *******************************************************************************/
2648              cyisraddress CyIntGetVector(uint8 number) 
2649              {
2650   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2651   1      
2652   1              return ((cyisraddress) \
2653   1                      CY_GET_REG16(&CY_INT_VECT_TABLE[number & CY_INT_NUMBER_MASK]));
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 44  

2654   1          }
2655          
2656          
2657              /*******************************************************************************
2658              * Function Name: CyIntSetPriority
2659              ********************************************************************************
2660              *
2661              * Summary:
2662              *  Sets the Priority of the Interrupt.
2663              *
2664              * Parameters:
2665              *  priority: Priority of the interrupt. 0 - 7, 0 being the highest.
2666              *  number:   The number of the interrupt, 0 - 31.
2667              *
2668              * Return:
2669              *  None
2670              *
2671              *******************************************************************************/
2672              void CyIntSetPriority(uint8 number, uint8 priority) 
2673              {
2674   1              CYASSERT(priority <= CY_INT_PRIORITY_MAX);
2675   1      
2676   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2677   1      
2678   1              CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] =
2679   1                          (priority & CY_INT_PRIORITY_MASK) << 5;
2680   1          }
2681          
2682          
2683              /*******************************************************************************
2684              * Function Name: CyIntGetPriority
2685              ********************************************************************************
2686              *
2687              * Summary:
2688              *  Gets the Priority of the Interrupt.
2689              *
2690              * Parameters:
2691              *  number: The number of the interrupt, 0 - 31.
2692              *
2693              * Return:
2694              *  Priority of the interrupt. 0 - 7, 0 being the highest.
2695              *
2696              *******************************************************************************/
2697              uint8 CyIntGetPriority(uint8 number) 
2698              {
2699   1              uint8 priority;
2700   1      
2701   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2702   1      
2703   1              priority = CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] >> 5;
2704   1      
2705   1              return (priority);
2706   1          }
2707          
2708          
2709              /*******************************************************************************
2710              * Function Name: CyIntGetState
2711              ********************************************************************************
2712              *
2713              * Summary:
2714              *   Gets the enable state of the specified interrupt number.
2715              *
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 45  

2716              * Parameters:
2717              *   number: Valid range [0-31].  Interrupt number.
2718              *
2719              * Return:
2720              *   Enable status: 1 if enabled, 0 if disabled
2721              *
2722              *******************************************************************************/
2723              uint8 CyIntGetState(uint8 number) 
2724              {
2725   1              reg8 * stateReg;
2726   1      
2727   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2728   1      
2729   1              /* Get a pointer to the Interrupt enable register. */
2730   1              stateReg = CY_INT_ENABLE_PTR + ((number & CY_INT_NUMBER_MASK) >> 3u);
2731   1      
2732   1              /* Get the state of the interrupt. */
2733   1              return ((0u != (*stateReg & ((uint8)(1u << (0x07u & number))))) ? ((uint8)(1u)) : ((uint8)(0u)));
2734   1          }
2735          
2736          
2737          #endif  /* (CY_PSOC5) */
2738          
2739          
2740          #if(!CY_PSOC5A)
2741          
2742              #if(CYDEV_VARIABLE_VDDA == 1)
              
              
                      /*******************************************************************************
                      * Function Name: CySetScPumps
                      ********************************************************************************
                      *
                      * Summary:
                      *  If 1 is passed as a parameter:
                      *   - if any of the SC blocks are used - enable pumps for the SC blocks and
                      *     start boost clock.
                      *   - For the each enabled SC block set boost clock index and enable boost clock.
                      *
                      *  If non-1 value is passed as a parameter:
                      *   - If all SC blocks are not used - disable pumps for the SC blocks and
                      *     stop boost clock.
                      *   - For the each enabled SC block clear boost clock index and disable boost
                      *     clock.
                              *
                      *  The global variable CyScPumpEnabled is updated to be equal to passed
                      *  parameter.
                      *
                      * Parameters:
                      *   uint8 enable: Enable/disable SC pumps and boost clock for enabled SC block.
                      *                 1 - Enable
                      *                 0 - Disable
                      *
                      * Return:
                      *   None
                      *
                      *******************************************************************************/
                      void CySetScPumps(uint8 enable) 
                      {
              
                          if(1u == enable)
                          {
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 46  

                              /* The SC pumps should be enabled */
                              CyScPumpEnabled = 1u;
              
              
                              /* Enable pumps if any of SC blocks are used */
                              if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAPS_MASK))
                              {
              
                                  CY_LIB_SC_MISC_REG |= CY_LIB_SC_MISC_PUMP_FORCE;
              
                                  CyScBoostClk_Start();
                              }
              
              
                              /* Set positive pump for each enabled SC block: set clock index and enable it */
                              if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP0_EN))
                              {
                                  CY_LIB_SC0_BST_REG = (CY_LIB_SC0_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostCl
             -k__INDEX;
                                  CY_LIB_SC0_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                              }
              
                              if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP1_EN))
                              {
                                  CY_LIB_SC1_BST_REG = (CY_LIB_SC1_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostCl
             -k__INDEX;
                                  CY_LIB_SC1_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                              }
              
                              if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP2_EN))
                              {
                                  CY_LIB_SC2_BST_REG = (CY_LIB_SC2_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostCl
             -k__INDEX;
                                  CY_LIB_SC2_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                              }
              
                              if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP3_EN))
                              {
                                  CY_LIB_SC3_BST_REG = (CY_LIB_SC3_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostCl
             -k__INDEX;
                                  CY_LIB_SC3_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                              }
                          }
                          else
                          {
                              /* The SC pumps should be disabled */
                              CyScPumpEnabled = 0u;
              
                              /* Disable pumps for all SC blocks and stop boost clock */
                              CY_LIB_SC_MISC_REG &= ((uint8)(~CY_LIB_SC_MISC_PUMP_FORCE));
                              CyScBoostClk_Stop();
              
                              /* Disable boost clock and clear clock index for each SC block */
                              CY_LIB_SC0_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                              CY_LIB_SC0_BST_REG = CY_LIB_SC0_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
              
                              CY_LIB_SC1_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                              CY_LIB_SC1_BST_REG = CY_LIB_SC1_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
              
                              CY_LIB_SC2_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                              CY_LIB_SC2_BST_REG = CY_LIB_SC2_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
              
C51 COMPILER V9.03   CYLIB                                                                 03/09/2016 17:02:33 PAGE 47  

                              CY_LIB_SC3_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                              CY_LIB_SC3_BST_REG = CY_LIB_SC3_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          }
                      }
              
                  #endif  /* (CYDEV_VARIABLE_VDDA == 1) */
2842          
2843          #endif /* (!CY_PSOC5A) */
2844          
2845          
2846          /* [] END OF FILE */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2939    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     14      48
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
